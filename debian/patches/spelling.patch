Description: Fix some spelling errors to silence lintian enabling  to concentrate on the real problem.
Author: Andreas Tille <tille@debian.org>,
Rashad Kanavath<rashad.kanavath@c-s.fr>,
Bas Couwenberg <sebastic@xs4all.nl>
Last-Update: 2015-12-22

--- otb.orig/Modules/Applications/AppChangeDetection/app/otbMultivariateAlterationDetector.cxx
+++ otb/Modules/Applications/AppChangeDetection/app/otbMultivariateAlterationDetector.cxx
@@ -75,7 +75,7 @@
                   " \n"
                   " The GetV1() and GetV2() methods allow to retrieve the linear "
                   " combinations used to generate the Mad change maps as a vnl_matrix of "
-                  " double, and the GetRho() method allows to retrieve the correlation "
+                  " double, and the GetRho() method allows one to retrieve the correlation "
                   " associated to each Mad change maps as a vnl_vector. \n"
                   " \n"
                   " This filter has been implemented from the Matlab code kindly made "
--- otb.orig/Modules/Applications/AppClassification/app/otbClassificationMapRegularization.cxx
+++ otb/Modules/Applications/AppClassification/app/otbClassificationMapRegularization.cxx
@@ -71,7 +71,7 @@
 
     /** GROUP IO CLASSIFICATION */
     AddParameter(ParameterType_Group,"io","Input and output images");
-    SetParameterDescription("io","This group of parameters allows to set input and output images for classification map regularization by Majority Voting.");
+    SetParameterDescription("io","This group of parameters allows one to set input and output images for classification map regularization by Majority Voting.");
 
     AddParameter(ParameterType_InputImage, "io.in",  "Input classification image");
     SetParameterDescription( "io.in", "The input labeled image to regularize.");
@@ -82,7 +82,7 @@
 
 
     AddParameter(ParameterType_Group,"ip","Regularization parameters");
-    SetParameterDescription("ip","This group allows to set parameters for classification map regularization by Majority Voting.");
+    SetParameterDescription("ip","This group allows one to set parameters for classification map regularization by Majority Voting.");
 
     AddParameter(ParameterType_Int, "ip.radius", "Structuring element radius (in pixels)");
     SetParameterDescription("ip.radius", "The radius of the ball shaped structuring element (expressed in pixels). By default, 'ip.radius = 1 pixel'.");
--- otb.orig/Modules/Applications/AppClassification/app/otbFusionOfClassifications.cxx
+++ otb/Modules/Applications/AppClassification/app/otbFusionOfClassifications.cxx
@@ -95,7 +95,7 @@
     SetName("FusionOfClassifications");
     SetDescription("Fuses several classifications maps of the same image on the basis of class labels.");
     SetDocName("Fusion of Classifications");
-    SetDocLongDescription("This application allows to fuse several classification maps and produces a single more robust classification map. "
+    SetDocLongDescription("This application allows one to fuse several classification maps and produces a single more robust classification map. "
         "Fusion is done either by mean of Majority Voting, or with the Dempster Shafer combination method on class labels.\n "
         "-MAJORITY VOTING: for each pixel, the class with the highest number of votes is selected.\n "
         "-DEMPSTER SHAFER: for each pixel, the class label for which the Belief Function is maximal is selected. This Belief Function is calculated "
@@ -346,7 +346,7 @@
         std::vector<std::string> confusionMatricesFilenameList = GetParameterStringList("method.dempstershafer.cmfl");
 
         MassOfBeliefDefinitionMethod massOfBeliefDefMethod;
-        //setting default to supress warning
+        //setting default to suppress warning
         massOfBeliefDefMethod = ConfusionMatrixToMassOfBeliefType::PRECISION;
         switch (GetParameterInt("method.dempstershafer.mob"))
           {
--- otb.orig/Modules/Applications/AppClassification/app/otbImageClassifier.cxx
+++ otb/Modules/Applications/AppClassification/app/otbImageClassifier.cxx
@@ -81,7 +81,7 @@
     SetParameterDescription( "in", "The input image to classify.");
 
     AddParameter(ParameterType_InputImage,  "mask",   "Input Mask");
-    SetParameterDescription( "mask", "The mask allows to restrict classification of the input image to the area where mask pixel values are greater than 0.");
+    SetParameterDescription( "mask", "The mask allows one to restrict classification of the input image to the area where mask pixel values are greater than 0.");
     MandatoryOff("mask");
 
     AddParameter(ParameterType_InputFilename, "model", "Model file");
--- otb.orig/Modules/Applications/AppDescriptors/app/otbHomologousPointsExtraction.cxx
+++ otb/Modules/Applications/AppDescriptors/app/otbHomologousPointsExtraction.cxx
@@ -81,19 +81,19 @@
   {
     SetName("HomologousPointsExtraction");
     SetDocName("Homologous points extraction");
-    SetDescription("Allows to compute homologous points between images using keypoints");
-    SetDocLongDescription("This application allows to compute homologous points between images using keypoints. "
+    SetDescription("allows one to compute homologous points between images using keypoints");
+    SetDocLongDescription("This application allows one to compute homologous points between images using keypoints. "
       " SIFT or SURF keypoints can be used and the band on which keypoints are computed can be set independantly for both images."
       " The application offers two modes :"
       " the first is the full mode where keypoints are extracted from the full extent of both images"
       " (please note that in this mode large image file are not supported). "
-      "The second mode, called geobins, allows to set-up spatial binning to get fewer points"
+      "The second mode, called geobins, allows one to set-up spatial binning to get fewer points"
       " spread accross the entire image. "
       "In this mode, the corresponding spatial bin in the second image is estimated using geographical"
       " transform or sensor modelling, and is padded according to the user defined precision. Last, in"
       " both modes the application can filter matches whose colocalisation in first image exceed this precision. "
       "The elevation parameters are to deal more precisely with sensor modelling in case of sensor geometry data. "
-      "The outvector option allows to create a vector file with segments corresponding to the localisation error between the matches."
+      "The outvector option allows one to create a vector file with segments corresponding to the localisation error between the matches."
       " It can be useful to assess the precision of a registration for instance."
       " The vector file is always reprojected to EPSG:4326 to allow display in a GIS."
       " This is done via reprojection or by applying the image sensor models.");
@@ -175,7 +175,7 @@
     SetDefaultParameterFloat("precision",0.);
 
     AddParameter(ParameterType_Empty,"mfilter","Filter points according to geographical or sensor based colocalisation");
-    SetParameterDescription("mfilter","If enabled, this option allows to filter matches according to colocalisation from sensor or geographical information, using the given tolerancy expressed in pixels");
+    SetParameterDescription("mfilter","If enabled, this option allows one to filter matches according to colocalisation from sensor or geographical information, using the given tolerancy expressed in pixels");
 
     AddParameter(ParameterType_Empty,"2wgs84","If enabled, points from second image will be exported in WGS84");
 
--- otb.orig/Modules/Applications/AppEdge/app/otbLineSegmentDetection.cxx
+++ otb/Modules/Applications/AppEdge/app/otbLineSegmentDetection.cxx
@@ -57,7 +57,7 @@
 
     // Documentation
     SetDocName("Line segment detection");
-    SetDocLongDescription("This application detects locally straight contours in a image. It is based on Burns, Hanson, and Riseman method and use an a contrario validation approach (Desolneux, Moisan, and Morel). The algorithm was published by Rafael Gromponevon Gioi, Jérémie Jakubowicz, Jean-Michel Morel and Gregory Randall.\n The given approach computes gradient and level lines of the image and detects aligned points in line support region. The application allows to export the detected lines in a vector data.");
+    SetDocLongDescription("This application detects locally straight contours in a image. It is based on Burns, Hanson, and Riseman method and use an a contrario validation approach (Desolneux, Moisan, and Morel). The algorithm was published by Rafael Gromponevon Gioi, Jérémie Jakubowicz, Jean-Michel Morel and Gregory Randall.\n The given approach computes gradient and level lines of the image and detects aligned points in line support region. The application allows one to export the detected lines in a vector data.");
     SetDocLimitations("None");
     SetDocAuthors("OTB-Team");
     SetDocSeeAlso("On Line demonstration of the LSD algorithm is available here: http://www.ipol.im/pub/algo/gjmr_line_segment_detector/\n");
--- otb.orig/Modules/Applications/AppHyperspectral/app/otbHyperspectralUnmixing.cxx
+++ otb/Modules/Applications/AppHyperspectral/app/otbHyperspectralUnmixing.cxx
@@ -96,7 +96,7 @@
 
     // Documentation
     SetDocName("Hyperspectral data unmixing");
-    SetDocLongDescription("The application applies a linear unmixing algorithm to an hyperspectral data cube. This method supposes that the mixture between materials in the scene is macroscopic and simulates a linear mixing model of spectra.\nThe Linear Mixing Model (LMM) acknowledges that reflectance spectrum associated with each pixel is a linear combination of pure materials in the recovery area, commonly known as endmembers. Endmembers can be estimated using the VertexComponentAnalysis application.\nThe application allows to estimate the abundance maps with several algorithms : Unconstrained Least Square (ucls), Fully Constrained Least Square (fcls), Image Space Reconstruction Algorithm (isra) and Non-negative constrained Least Square (ncls) and Minimum Dispertion Constrained Non Negative Matrix Factorization (MDMDNMF).\n");
+    SetDocLongDescription("The application applies a linear unmixing algorithm to an hyperspectral data cube. This method supposes that the mixture between materials in the scene is macroscopic and simulates a linear mixing model of spectra.\nThe Linear Mixing Model (LMM) acknowledges that reflectance spectrum associated with each pixel is a linear combination of pure materials in the recovery area, commonly known as endmembers. Endmembers can be estimated using the VertexComponentAnalysis application.\nThe application allows one to estimate the abundance maps with several algorithms : Unconstrained Least Square (ucls), Fully Constrained Least Square (fcls), Image Space Reconstruction Algorithm (isra) and Non-negative constrained Least Square (ncls) and Minimum Dispersion Constrained Non Negative Matrix Factorization (MDMDNMF).\n");
     SetDocLimitations("None");
     SetDocAuthors("OTB-Team");
     SetDocSeeAlso("VertexComponentAnalysis");
@@ -128,7 +128,7 @@
     SetParameterDescription("ua.isra", "Image Space Reconstruction Algorithm");
 
     AddChoice("ua.mdmdnmf", "MDMDNMF");
-    SetParameterDescription("ua.mdmdnmf", "Minimum Dispertion Constrained Non Negative Matrix Factorization");
+    SetParameterDescription("ua.mdmdnmf", "Minimum Dispersion Constrained Non Negative Matrix Factorization");
     SetParameterString("ua", "ucls");
     // Doc example parameter settings
     SetDocExampleParameterValue("in", "cupriteSubHsi.tif");
--- otb.orig/Modules/Applications/AppImageUtils/app/otbColorMapping.cxx
+++ otb/Modules/Applications/AppImageUtils/app/otbColorMapping.cxx
@@ -250,10 +250,10 @@
     SetDescription("Maps an input label image to 8-bits RGB using look-up tables.");
 
     SetDocName("Color Mapping");
-    SetDocLongDescription("This application allows to map a label image to a 8-bits RGB image (in both ways) using different methods.\n"
-                          " -The custom method allows to use a custom look-up table. The look-up table is loaded "
+    SetDocLongDescription("This application allows one to map a label image to a 8-bits RGB image (in both ways) using different methods.\n"
+                          " -The custom method allows one to use a custom look-up table. The look-up table is loaded "
                           "from a text file where each line describes an entry. The typical use of this method is to colorise a "
-                          "classification map.\n -The continuous method allows to map a range of values in a scalar input image "
+                          "classification map.\n -The continuous method allows one to map a range of values in a scalar input image "
                           "to a colored image using continuous look-up table, in order to enhance image interpretation. Several "
                           "look-up tables can been chosen with different color ranges.\n-The optimal method computes an optimal "
                           "look-up table. When processing a segmentation label image (label to color), the color difference between"
--- otb.orig/Modules/Applications/AppImageUtils/app/otbDownloadSRTMTiles.cxx
+++ otb/Modules/Applications/AppImageUtils/app/otbDownloadSRTMTiles.cxx
@@ -96,7 +96,7 @@
 
     // Documentation
     SetDocName("Download or list SRTM tiles related to a set of images");
-    SetDocLongDescription("This application allows to select the appropriate SRTM tiles that covers a list of images. It builds a list of the required tiles. Two modes are available: the first one download those tiles from the USGS SRTM3 website (http://dds.cr.usgs.gov/srtm/version2_1/SRTM3/), the second one list those tiles in a local directory. In both cases, you need to indicate the directory in which directory  tiles will be download or the location of local SRTM files.");
+    SetDocLongDescription("This application allows one to select the appropriate SRTM tiles that covers a list of images. It builds a list of the required tiles. Two modes are available: the first one download those tiles from the USGS SRTM3 website (http://dds.cr.usgs.gov/srtm/version2_1/SRTM3/), the second one list those tiles in a local directory. In both cases, you need to indicate the directory in which directory  tiles will be download or the location of local SRTM files.");
     SetDocLimitations("None");
     SetDocAuthors("OTB-Team");
     SetDocSeeAlso(" ");
--- otb.orig/Modules/Applications/AppImageUtils/app/otbMultiResolutionPyramid.cxx
+++ otb/Modules/Applications/AppImageUtils/app/otbMultiResolutionPyramid.cxx
@@ -95,7 +95,7 @@
     // Boolean Fast scheme
     AddParameter(ParameterType_Empty, "fast", "Use Fast Scheme");
     std::ostringstream desc;
-    desc<<"If used, this option allows to speed-up computation by iteratively"
+    desc<<"If used, this option allows one to speed-up computation by iteratively"
         <<" subsampling previous level of pyramid instead of processing the full input.";
     SetParameterDescription("fast", desc.str());
     MandatoryOff("fast");
--- otb.orig/Modules/Applications/AppImageUtils/app/otbReadImageInfo.cxx
+++ otb/Modules/Applications/AppImageUtils/app/otbReadImageInfo.cxx
@@ -179,7 +179,7 @@
     EnableParameter("country");
 
     AddParameter(ParameterType_Group, "rgb", "Default RGB Display");
-    SetParameterDescription("rgb","This group of parameters allows to access to the default rgb composition.");
+    SetParameterDescription("rgb","This group of parameters allows one to access to the default rgb composition.");
 
     AddParameter(ParameterType_Int, "rgb.r", "Red Band");
     SetParameterDescription("rgb.r","Red band Number");
@@ -491,7 +491,7 @@
       ossOutput << "\t" << GetParameterString("keyword") << std::endl;
       }
 
-    //Display image informations in the dedicated logger
+    //Display image information in the dedicated logger
     otbAppLogINFO( << ossOutput.str() );
 
     if(IsParameterEnabled("outkwl"))
--- otb.orig/Modules/Applications/AppMathParserX/app/otbBandMathX.cxx
+++ otb/Modules/Applications/AppMathParserX/app/otbBandMathX.cxx
@@ -108,7 +108,7 @@
       "matrices (for instance cos, sin, ...). These new operators/ functions keep the original names to which we added the prefix 'v' for vector (vcos, vsin, ...).\n"
       "- mult, div and pow operators, that perform element-wise multiplication, division or exponentiation of vector/matrices (for instance im1 div im2)\n"
       "- mlt, dv and pw operators, that perform multiplication, division or exponentiation of vector/matrices by a scalar (for instance im1 dv 2.0)\n"
-      "- bands, which is a very usefull operator. It allows to select specific bands from an image, and/or to rearrange them in a new vector;\n"
+      "- bands, which is a very usefull operator. It allows one to select specific bands from an image, and/or to rearrange them in a new vector;\n"
       "for instance bands(im1,{1,2,1,1}) produces a vector of 4 components made of band 1, band 2, band 1 and band 1 values from the first input.\n"
       "Note that curly brackets must be used in order to select the desired band indices.\n"
       "... and so on.\n"
@@ -126,7 +126,7 @@
       "In the latter case, elements of a row must be separated by commas, and rows must be separated by semicolons.\n"
       "It is also possible to define expressions within the same txt file, with the pattern #E expr. For instance (two expressions; see also limitations section below):\n\n"
       "#E $dotpr(kernel1,im1b1N3x5); im2b1^expo$\n"
-      "\n- The 'outcontext' parameter allows to save user's constants and expressions (context).\n"
+      "\n- The 'outcontext' parameter allows one to save user's constants and expressions (context).\n"
       "- Setting the output image can be done with the 'out' parameter (multi-outputs is not implemented yet).\n"
       "\n\n"
       "Finally, we strongly recommend that the reader takes a look at the cookbook, where additional information can be found (http://www.orfeo-toolbox.org/packages/OTBCookBook.pdf).\n"
@@ -234,5 +234,3 @@
 } // namespace otb
 
 OTB_APPLICATION_EXPORT(otb::Wrapper::BandMathX)
-
-
--- otb.orig/Modules/Applications/AppOpticalCalibration/app/otbOpticalCalibration.cxx
+++ otb/Modules/Applications/AppOpticalCalibration/app/otbOpticalCalibration.cxx
@@ -124,10 +124,10 @@
   void DoInit()
   {
     SetName("OpticalCalibration");
-    SetDescription("Perform optical calibration TOA/TOC (Top Of Atmosphere/Top Of Canopy). Supported sensors: QuickBird, Ikonos, WorldView2, Formosat, Spot5, Pleiades, Spot6. For other sensors the application also allows to provide calibration parameters manually.");
+    SetDescription("Perform optical calibration TOA/TOC (Top Of Atmosphere/Top Of Canopy). Supported sensors: QuickBird, Ikonos, WorldView2, Formosat, Spot5, Pleiades, Spot6. For other sensors the application also allows one to provide calibration parameters manually.");
     // Documentation
     SetDocName("Optical calibration");
-    SetDocLongDescription("The application allows to convert pixel values from DN (for Digital Numbers) to reflectance. Calibrated values are called surface reflectivity and its values lie in the range [0, 1].\nThe first level is called Top Of Atmosphere (TOA) reflectivity. It takes into account the sensor gain, sensor spectral response and the solar illuminations.\nThe second level is called Top Of Canopy (TOC) reflectivity. In addition to sensor gain and solar illuminations, it takes into account the optical thickness of the atmosphere, the atmospheric pressure, the water vapor amount, the ozone amount, as well as the composition and amount of aerosol gasses.\nIt is also possible to indicate an AERONET file which contains atmospheric parameters (version 1 and version 2 of Aeronet file are supported. Note that computing TOC reflectivity will internally compute first TOA and then TOC reflectance. \n"
+    SetDocLongDescription("The application allows one to convert pixel values from DN (for Digital Numbers) to reflectance. Calibrated values are called surface reflectivity and its values lie in the range [0, 1].\nThe first level is called Top Of Atmosphere (TOA) reflectivity. It takes into account the sensor gain, sensor spectral response and the solar illuminations.\nThe second level is called Top Of Canopy (TOC) reflectivity. In addition to sensor gain and solar illuminations, it takes into account the optical thickness of the atmosphere, the atmospheric pressure, the water vapor amount, the ozone amount, as well as the composition and amount of aerosol gasses.\nIt is also possible to indicate an AERONET file which contains atmospheric parameters (version 1 and version 2 of Aeronet file are supported. Note that computing TOC reflectivity will internally compute first TOA and then TOC reflectance. \n"
 "\n--------------------------\n\n"
 "If the sensor is not supported by the metadata interface factory of OTB, users still have the possibility to give the needed parameters to the application.\n"
 "For TOA conversion, these parameters are : \n"
@@ -198,7 +198,7 @@
 
     AddParameter(ParameterType_Empty, "milli", "Convert to milli reflectance");
     SetParameterDescription("milli", "Flag to use milli-reflectance instead of reflectance.\n"
-                            "This allows to save the image with integer pixel type (in the range [0, 1000]  instead of floating point in the range [0, 1]. In order to do that, use this option and set the output pixel type (-out filename double for example)");
+                            "This allows one to save the image with integer pixel type (in the range [0, 1000]  instead of floating point in the range [0, 1]. In order to do that, use this option and set the output pixel type (-out filename double for example)");
     DisableParameter("milli");
     MandatoryOff("milli");
 
@@ -209,7 +209,7 @@
 
     //Acquisition parameters
     AddParameter(ParameterType_Group,"acqui","Acquisition parameters");
-    SetParameterDescription("acqui","This group allows to set the parameters related to the acquisition conditions.");
+    SetParameterDescription("acqui","This group allows one to set the parameters related to the acquisition conditions.");
     //Minute
     AddParameter(ParameterType_Int, "acqui.minute",   "Minute");
     SetParameterDescription("acqui.minute", "Minute (0-59)");
@@ -285,7 +285,7 @@
 
     //Atmospheric parameters (TOC)
     AddParameter(ParameterType_Group,"atmo","Atmospheric parameters (for TOC)");
-    SetParameterDescription("atmo","This group allows to set the atmospheric parameters.");
+    SetParameterDescription("atmo","This group allows one to set the atmospheric parameters.");
     AddParameter(ParameterType_Choice,   "atmo.aerosol", "Aerosol Model");
     AddChoice("atmo.aerosol.noaersol",    "No Aerosol Model");
     AddChoice("atmo.aerosol.continental", "Continental");
--- otb.orig/Modules/Applications/AppProjection/app/otbGenerateRPCSensorModel.cxx
+++ otb/Modules/Applications/AppProjection/app/otbGenerateRPCSensorModel.cxx
@@ -60,7 +60,7 @@
     SetDescription("Generate a RPC sensor model from a list of Ground Control Points.");
 
     SetDocName("Generate a RPC sensor model");
-    SetDocLongDescription("This application generates a RPC sensor model from a list of Ground Control Points. At least 20 points are required for estimation wihtout elevation support, and 40 points for estimation with elevation support. Elevation support will be automatically deactivated if an insufficient amount of points is provided. The application can optionnaly output a file containing accuracy statistics for each point, and a vector file containing segments represening points residues. The map projection parameter allows to define a map projection in which the accuracy is evaluated.");
+    SetDocLongDescription("This application generates a RPC sensor model from a list of Ground Control Points. At least 20 points are required for estimation wihtout elevation support, and 40 points for estimation with elevation support. Elevation support will be automatically deactivated if an insufficient amount of points is provided. The application can optionnaly output a file containing accuracy statistics for each point, and a vector file containing segments represening points residues. The map projection parameter allows one to define a map projection in which the accuracy is evaluated.");
 
     AddDocTag(Tags::Geometry);
 
--- otb.orig/Modules/Applications/AppProjection/app/otbGridBasedImageResampling.cxx
+++ otb/Modules/Applications/AppProjection/app/otbGridBasedImageResampling.cxx
@@ -107,7 +107,7 @@
     SetDescription("Resamples an image according to a resampling grid");
 
     SetDocName("Grid Based Image Resampling");
-    SetDocLongDescription("This application allows to perform image resampling from an input resampling grid.");
+    SetDocLongDescription("This application allows one to perform image resampling from an input resampling grid.");
     SetDocLimitations("None");
     SetDocAuthors("OTB-Team");
 
@@ -116,7 +116,7 @@
     SetDocSeeAlso("otbStereorecificationGridGeneration");
 
     AddParameter(ParameterType_Group,"io","Input and output data");
-    SetParameterDescription("io","This group of parameters allows to set the input and output images.");
+    SetParameterDescription("io","This group of parameters allows one to set the input and output images.");
     AddParameter(ParameterType_InputImage,"io.in","Input image");
     SetParameterDescription("io.in","The input image to resample");
     AddParameter(ParameterType_OutputImage, "io.out", "Output Image");
@@ -126,7 +126,7 @@
     AddParameter(ParameterType_InputImage,"grid.in","Input resampling grid");
     SetParameterDescription("grid.in","The resampling grid");
     AddParameter(ParameterType_Choice,   "grid.type", "Grid Type");
-    SetParameterDescription("grid.type","Allows to choose between two grid types");
+    SetParameterDescription("grid.type","allows one to choose between two grid types");
     AddChoice("grid.type.def","Displacement  grid: $G(x_out,y_out) = (x_in-x_out, y_in-y_out)$");
     SetParameterDescription("grid.type.def","A deformation grid contains at each grid position the offset to apply to this position in order to get to the corresponding point in the input image to resample");
     AddChoice("grid.type.loc","Localisation grid: $G(x_out,y_out) = (x_in, y_in)$");
@@ -161,14 +161,14 @@
 
     // Interpolators
     AddParameter(ParameterType_Choice,   "interpolator", "Interpolation");
-    SetParameterDescription("interpolator","This group of parameters allows to define how the input image will be interpolated during resampling.");
+    SetParameterDescription("interpolator","This group of parameters allows one to define how the input image will be interpolated during resampling.");
     AddChoice("interpolator.nn",     "Nearest Neighbor interpolation");
     SetParameterDescription("interpolator.nn","Nearest neighbor interpolation leads to poor image quality, but it is very fast.");
     AddChoice("interpolator.linear", "Linear interpolation");
     SetParameterDescription("interpolator.linear","Linear interpolation leads to average image quality but is quite fast");
     AddChoice("interpolator.bco",    "Bicubic interpolation");
     AddParameter(ParameterType_Radius, "interpolator.bco.radius", "Radius for bicubic interpolation");
-    SetParameterDescription("interpolator.bco.radius","This parameter allows to control the size of the bicubic interpolation filter. If the target pixel size is higher than the input pixel size, increasing this parameter will reduce aliasing artefacts.");
+    SetParameterDescription("interpolator.bco.radius","This parameter allows one to control the size of the bicubic interpolation filter. If the target pixel size is higher than the input pixel size, increasing this parameter will reduce aliasing artefacts.");
     SetDefaultParameterInt("interpolator.bco.radius", 2);
     SetParameterString("interpolator","bco");
 
--- otb.orig/Modules/Applications/AppProjection/app/otbOrthoRectification.cxx
+++ otb/Modules/Applications/AppProjection/app/otbOrthoRectification.cxx
@@ -88,7 +88,7 @@
   {
     SetName("OrthoRectification");
     std::ostringstream oss;
-    oss << "This application allows to ortho-rectify optical images from supported sensors." << std::endl;
+    oss << "This application allows one to ortho-rectify optical images from supported sensors." << std::endl;
     SetDescription(oss.str());
     // Documentation
     SetDocName("Ortho-rectification");
@@ -106,7 +106,7 @@
 
     // Set the parameters
     AddParameter(ParameterType_Group,"io","Input and output data");
-    SetParameterDescription("io","This group of parameters allows to set the input and output images.");
+    SetParameterDescription("io","This group of parameters allows one to set the input and output images.");
     AddParameter(ParameterType_InputImage, "io.in", "Input Image");
     SetParameterDescription("io.in","The input image to ortho-rectify");
     AddParameter(ParameterType_OutputImage, "io.out", "Output Image");
@@ -117,7 +117,7 @@
 
     // Add the output paramters in a group
     AddParameter(ParameterType_Group, "outputs", "Output Image Grid");
-    SetParameterDescription("outputs","This group of parameters allows to define the grid on which the input image will be resampled.");
+    SetParameterDescription("outputs","This group of parameters allows one to define the grid on which the input image will be resampled.");
 
     // UserDefined values
     AddParameter(ParameterType_Choice, "outputs.mode", "Parameters estimation modes");
@@ -177,7 +177,7 @@
     std::ostringstream isotropOss;
     isotropOss << "Default spacing (pixel size) values are estimated from the sensor modeling of the image. It can therefore result in a non-isotropic spacing. ";
     isotropOss << "This option allows you to force default values to be isotropic (in this case, the minimum of spacing in both direction is applied. ";
-    isotropOss << "Values overriden by user are not affected by this option.";
+    isotropOss << "Values overridden by user are not affected by this option.";
     SetParameterDescription("outputs.isotropic", isotropOss.str());
     EnableParameter("outputs.isotropic");
 
@@ -193,26 +193,26 @@
     AddParameter(ParameterType_Choice,   "interpolator", "Interpolation");
     AddChoice("interpolator.bco",    "Bicubic interpolation");
     AddParameter(ParameterType_Radius, "interpolator.bco.radius", "Radius for bicubic interpolation");
-    SetParameterDescription("interpolator.bco.radius","This parameter allows to control the size of the bicubic interpolation filter. If the target pixel size is higher than the input pixel size, increasing this parameter will reduce aliasing artefacts.");
-    SetParameterDescription("interpolator","This group of parameters allows to define how the input image will be interpolated during resampling.");
+    SetParameterDescription("interpolator.bco.radius","This parameter allows one to control the size of the bicubic interpolation filter. If the target pixel size is higher than the input pixel size, increasing this parameter will reduce aliasing artefacts.");
+    SetParameterDescription("interpolator","This group of parameters allows one to define how the input image will be interpolated during resampling.");
     AddChoice("interpolator.nn",     "Nearest Neighbor interpolation");
     SetParameterDescription("interpolator.nn","Nearest neighbor interpolation leads to poor image quality, but it is very fast.");
     AddChoice("interpolator.linear", "Linear interpolation");
     SetParameterDescription("interpolator.linear","Linear interpolation leads to average image quality but is quite fast");
     SetDefaultParameterInt("interpolator.bco.radius", 2);
     AddParameter(ParameterType_Group,"opt","Speed optimization parameters");
-    SetParameterDescription("opt","This group of parameters allows to optimize processing time.");
+    SetParameterDescription("opt","This group of parameters allows one to optimize processing time.");
 
     // Estimate a RPC model (for spot image for instance)
     AddParameter(ParameterType_Int, "opt.rpc", "RPC modeling (points per axis)");
     SetDefaultParameterInt("opt.rpc", 10);
-    SetParameterDescription("opt.rpc","Enabling RPC modeling allows to speed-up SPOT5 ortho-rectification. Value is the number of control points per axis for RPC estimation");
+    SetParameterDescription("opt.rpc","Enabling RPC modeling allows one to speed-up SPOT5 ortho-rectification. Value is the number of control points per axis for RPC estimation");
     DisableParameter("opt.rpc");
     MandatoryOff("opt.rpc");
 
     // RAM available
     AddRAMParameter("opt.ram");
-    SetParameterDescription("opt.ram","This allows to set the maximum amount of RAM available for processing. As the writing task is time consuming, it is better to write large pieces of data, which can be achieved by increasing this parameter (pay attention to your system capabilities)");
+    SetParameterDescription("opt.ram","This allows one to set the maximum amount of RAM available for processing. As the writing task is time consuming, it is better to write large pieces of data, which can be achieved by increasing this parameter (pay attention to your system capabilities)");
 
     // Displacement Field Spacing
     AddParameter(ParameterType_Float, "opt.gridspacing", "Resampling grid spacing");
--- otb.orig/Modules/Applications/AppProjection/app/otbRefineSensorModel.cxx
+++ otb/Modules/Applications/AppProjection/app/otbRefineSensorModel.cxx
@@ -59,7 +59,7 @@
     SetDescription("Perform least-square fit of a sensor model to a set of tie points");
 
     SetDocName("Refine Sensor Model");
-    SetDocLongDescription("This application reads a geom file containing a sensor model and a text file containing a list of ground control point, and performs a least-square fit of the sensor model adjustable parameters to these tie points. It produces an updated geom file as output, as well as an optional ground control points based statistics file and a vector file containing residues. The output geom file can then be used to ortho-rectify the data more accurately. Plaease note that for a proper use of the application, elevation must be correctly set (including DEM and geoid file). The map parameters allows to choose a map projection in which the accuracy will be estimated in meters.");
+    SetDocLongDescription("This application reads a geom file containing a sensor model and a text file containing a list of ground control point, and performs a least-square fit of the sensor model adjustable parameters to these tie points. It produces an updated geom file as output, as well as an optional ground control points based statistics file and a vector file containing residues. The output geom file can then be used to ortho-rectify the data more accurately. Plaease note that for a proper use of the application, elevation must be correctly set (including DEM and geoid file). The map parameters allows one to choose a map projection in which the accuracy will be estimated in meters.");
 
     AddDocTag(Tags::Geometry);
 
--- otb.orig/Modules/Applications/AppProjection/app/otbRigidTransformResample.cxx
+++ otb/Modules/Applications/AppProjection/app/otbRigidTransformResample.cxx
@@ -100,7 +100,7 @@
 
     //Transform
     AddParameter(ParameterType_Group,"transform","Transform parameters");
-    SetParameterDescription("transform","This group of parameters allows to set the transformation to apply.");
+    SetParameterDescription("transform","This group of parameters allows one to set the transformation to apply.");
 
     AddParameter(ParameterType_Choice, "transform.type", "Type of transformation");
     SetParameterDescription("transform.type","Type of transformation. Available transformations are spatial scaling, translation and rotation with scaling factor");
@@ -148,20 +148,20 @@
 
     // Interpolators
     AddParameter(ParameterType_Choice,   "interpolator", "Interpolation");
-    SetParameterDescription("interpolator","This group of parameters allows to define how the input image will be interpolated during resampling.");
+    SetParameterDescription("interpolator","This group of parameters allows one to define how the input image will be interpolated during resampling.");
     AddChoice("interpolator.nn",     "Nearest Neighbor interpolation");
     SetParameterDescription("interpolator.nn","Nearest neighbor interpolation leads to poor image quality, but it is very fast.");
     AddChoice("interpolator.linear", "Linear interpolation");
     SetParameterDescription("interpolator.linear","Linear interpolation leads to average image quality but is quite fast");
     AddChoice("interpolator.bco",    "Bicubic interpolation");
     AddParameter(ParameterType_Radius, "interpolator.bco.radius", "Radius for bicubic interpolation");
-    SetParameterDescription("interpolator.bco.radius","This parameter allows to control the size of the bicubic interpolation filter. If the target pixel size is higher than the input pixel size, increasing this parameter will reduce aliasing artefacts.");
+    SetParameterDescription("interpolator.bco.radius","This parameter allows one to control the size of the bicubic interpolation filter. If the target pixel size is higher than the input pixel size, increasing this parameter will reduce aliasing artefacts.");
     SetDefaultParameterInt("interpolator.bco.radius", 2);
     SetParameterString("interpolator","bco");
 
     // RAM available
     AddRAMParameter("ram");
-    SetParameterDescription("ram","This allows to set the maximum amount of RAM available for processing. As the writing task is time consuming, it is better to write large pieces of data, which can be achieved by increasing this parameter (pay attention to your system capabilities)");
+    SetParameterDescription("ram","This allows one to set the maximum amount of RAM available for processing. As the writing task is time consuming, it is better to write large pieces of data, which can be achieved by increasing this parameter (pay attention to your system capabilities)");
 
     // Doc example parameter settings
     SetDocExampleParameterValue("in", "qb_toulouse_sub.tif");
--- otb.orig/Modules/Applications/AppProjection/app/otbVectorDataReprojection.cxx
+++ otb/Modules/Applications/AppProjection/app/otbVectorDataReprojection.cxx
@@ -61,13 +61,13 @@
   {
     SetName("VectorDataReprojection");
     std::ostringstream oss;
-    oss << "This application allows to reproject a vector data using support image projection reference"
+    oss << "This application allows one to reproject a vector data using support image projection reference"
         ", or a user specified map projection" << std::endl;
     SetDescription(oss.str());
     // Documentation
     SetDocName("Vector Data reprojection");
     oss.str("");
-    oss <<" This application allows to reproject a vector data using support image projection reference"
+    oss <<" This application allows one to reproject a vector data using support image projection reference"
         ", or a user given map projection." << std::endl;
     oss <<" If given, image keywordlist can be added to reprojected vectordata.";
     SetDocLongDescription(oss.str());
--- otb.orig/Modules/Applications/AppSegmentation/app/otbConnectedComponentSegmentation.cxx
+++ otb/Modules/Applications/AppSegmentation/app/otbConnectedComponentSegmentation.cxx
@@ -71,7 +71,7 @@
     SetName("ConnectedComponentSegmentation");
     SetDescription("Connected component segmentation and object based image filtering of the input image according to user-defined criterions.");
     SetDocName("Connected Component Segmentation");
-    SetDocLongDescription("This application allows to perform a masking, connected components segmentation and object based image filtering. First and optionally, a mask can be built based on user-defined criterions to select pixels of the image which will be segmented. Then a connected component segmentation is performed with a user defined criterion to decide whether two neighbouring pixels belong to the same segment or not. After this segmentation step, an object based image filtering is applied using another user-defined criterion reasoning on segment properties, like shape or radiometric attributes. " "Criterions are mathematical expressions analysed by the MuParser library (http://muparser.sourceforge.net/). For instance, expression \"((b1>80) and intensity>95)\" will merge two neighbouring pixel in a single segment if their intensity is more than 95 and their value in the first image band is more than 80. See parameters documentation for a list of available attributes. The output of the object based image filtering is vectorized and can be written in shapefile or KML format. If the input image is in raw geometry, resulting polygons will be transformed to WGS84 using sensor modelling before writing, to ensure consistency with GIS softwares. For this purpose, a Digital Elevation Model can be provided to the application. The whole processing is done on a per-tile basis for large images, so this application can handle images of arbitrary size.");
+    SetDocLongDescription("This application allows one to perform a masking, connected components segmentation and object based image filtering. First and optionally, a mask can be built based on user-defined criterions to select pixels of the image which will be segmented. Then a connected component segmentation is performed with a user defined criterion to decide whether two neighbouring pixels belong to the same segment or not. After this segmentation step, an object based image filtering is applied using another user-defined criterion reasoning on segment properties, like shape or radiometric attributes. " "Criterions are mathematical expressions analysed by the MuParser library (http://muparser.sourceforge.net/). For instance, expression \"((b1>80) and intensity>95)\" will merge two neighbouring pixel in a single segment if their intensity is more than 95 and their value in the first image band is more than 80. See parameters documentation for a list of available attributes. The output of the object based image filtering is vectorized and can be written in shapefile or KML format. If the input image is in raw geometry, resulting polygons will be transformed to WGS84 using sensor modelling before writing, to ensure consistency with GIS software. For this purpose, a Digital Elevation Model can be provided to the application. The whole processing is done on a per-tile basis for large images, so this application can handle images of arbitrary size.");
     SetDocLimitations("Due to the tiling scheme in case of large images, some segments can be arbitrarily split across multiple tiles.");
     SetDocAuthors("OTB-Team");
     SetDocSeeAlso(" ");
--- otb.orig/Modules/Applications/AppSegmentation/app/otbLSMSSegmentation.cxx
+++ otb/Modules/Applications/AppSegmentation/app/otbLSMSSegmentation.cxx
@@ -217,7 +217,7 @@
     SetDescription("Second step of the exact Large-Scale Mean-Shift segmentation workflow.");
 
     SetDocName("Exact Large-Scale Mean-Shift segmentation, step 2");
-    SetDocLongDescription("This application performs the second step of the exact Large-Scale Mean-Shift segmentation workflow (LSMS). Filtered range image and spatial image should be created with the MeanShiftSmoothing application, with modesearch parameter disabled. If spatial image is not set, the application will only process the range image and spatial radius parameter will not be taken into account. This application will produce a labeled image where neighbor pixels whose range distance is below range radius (and optionally spatial distance below spatial radius) will be grouped together into the same cluster. For large images one can use the nbtilesx and nbtilesy parameters for tile-wise processing, with the guarantees of identical results. Please note that this application will generate a lot of temporary files (as many as the number of tiles), and will therefore require twice the size of the final result in term of disk space. The cleanup option (activated by default) allows to remove all temporary file as soon as they are not needed anymore (if cleanup is activated, tmpdir set and tmpdir does not exists before running the application, it will be removed as well during cleanup). The tmpdir option allows to define a directory where to write the temporary files. Please also note that the output image type should be set to uint32 to ensure that there are enough labels available.");
+    SetDocLongDescription("This application performs the second step of the exact Large-Scale Mean-Shift segmentation workflow (LSMS). Filtered range image and spatial image should be created with the MeanShiftSmoothing application, with modesearch parameter disabled. If spatial image is not set, the application will only process the range image and spatial radius parameter will not be taken into account. This application will produce a labeled image where neighbor pixels whose range distance is below range radius (and optionally spatial distance below spatial radius) will be grouped together into the same cluster. For large images one can use the nbtilesx and nbtilesy parameters for tile-wise processing, with the guarantees of identical results. Please note that this application will generate a lot of temporary files (as many as the number of tiles), and will therefore require twice the size of the final result in term of disk space. The cleanup option (activated by default) allows one to remove all temporary file as soon as they are not needed anymore (if cleanup is activated, tmpdir set and tmpdir does not exists before running the application, it will be removed as well during cleanup). The tmpdir option allows one to define a directory where to write the temporary files. Please also note that the output image type should be set to uint32 to ensure that there are enough labels available.");
     SetDocLimitations("This application is part of the Large-Scale Mean-Shift segmentation workflow (LSMS) and may not be suited for any other purpose.");
     SetDocAuthors("David Youssefi");
     SetDocSeeAlso("MeanShiftSmoothing, LSMSSmallRegionsMerging, LSMSVectorization");
@@ -713,5 +713,3 @@
 }
 
 OTB_APPLICATION_EXPORT(otb::Wrapper::LSMSSegmentation)
-
-
--- otb.orig/Modules/Applications/AppSegmentation/app/otbSegmentation.cxx
+++ otb/Modules/Applications/AppSegmentation/app/otbSegmentation.cxx
@@ -138,7 +138,7 @@
 
     // Documentation
     SetDocName("Segmentation");
-    SetDocLongDescription("This application allows to perform various segmentation algorithms on a multispectral image."
+    SetDocLongDescription("This application allows one to perform various segmentation algorithms on a multispectral image."
                           "Available segmentation algorithms are two different versions of Mean-Shift segmentation algorithm (one being multi-threaded),"
                           " simple pixel based connected components according to a user-defined criterion, and watershed from the gradient of the intensity"
                           " (norm of spectral bands vector). The application has two different modes that affects the nature of its output.\n\nIn raster mode,"
@@ -147,8 +147,8 @@
                           " can not handle large images. \n\nTo segment large data, one can use the vector mode. In this case, the output of the application is a"
                           " vector file or database. The input image is split into tiles (whose size can be set using the tilesize parameter), and each tile is loaded, segmented"
                           " with the chosen algorithm, vectorized, and written into the output file or database. This piece-wise behavior ensure that memory will never get overloaded,"
-                          " and that images of any size can be processed. There are few more options in the vector mode. The simplify option allows to simplify the geometry"
-                          " (i.e. remove nodes in polygons) according to a user-defined tolerance. The stitch option allows to application to try to stitch together polygons corresponding"
+                          " and that images of any size can be processed. There are few more options in the vector mode. The simplify option allows one to simplify the geometry"
+                          " (i.e. remove nodes in polygons) according to a user-defined tolerance. The stitch option allows one to application to try to stitch together polygons corresponding"
                           " to segmented region that may have been split by the tiling scheme. ");
 
     SetDocLimitations("In raster mode, the application can not handle large input images. Stitching step of vector mode might become slow with very large input images."
@@ -223,7 +223,7 @@
     SetParameterDescription("mode", "Choice of processing mode, either raster or large-scale.");
 
     AddChoice("mode.vector", "Tile-based large-scale segmentation with vector output");
-    SetParameterDescription("mode.vector","In this mode, the application will output a vector file or database, and process the input image piecewise. This allows to perform segmentation of very large images.");
+    SetParameterDescription("mode.vector","In this mode, the application will output a vector file or database, and process the input image piecewise. This allows one to perform segmentation of very large images.");
 
     AddChoice("mode.raster", "Standard segmentation with labeled raster output");
     SetParameterDescription("mode.raster","In this mode, the application will output a standard labeled raster. This mode can not handle large data.");
@@ -258,7 +258,7 @@
     SetParameterDescription("mode.vector.out", "The output vector file or database (name can be anything understood by OGR)");
 
     AddParameter(ParameterType_Choice,"mode.vector.outmode","Writing mode for the output vector file");
-    SetParameterDescription("mode.vector.outmode","This allows to set the writing behaviour for the output vector file. Please note that the actual behaviour depends on the file format.");
+    SetParameterDescription("mode.vector.outmode","This allows one to set the writing behaviour for the output vector file. Please note that the actual behaviour depends on the file format.");
 
     AddChoice("mode.vector.outmode.ulco","Update output vector file, only allow to create new layers");
     SetParameterDescription("mode.vector.outmode.ulco","The output vector file is opened in update mode if existing. If the output layer already exists, the application stops, leaving it untouched.");
@@ -298,7 +298,7 @@
 
     AddParameter(ParameterType_Float, "mode.vector.simplify", "Simplify polygons");
     SetParameterDescription("mode.vector.simplify",
-                            "Simplify polygons according to a given tolerance (in pixel). This option allows to reduce the size of the output file or database.");
+                            "Simplify polygons according to a given tolerance (in pixel). This option allows one to reduce the size of the output file or database.");
     SetDefaultParameterFloat("mode.vector.simplify",0.1);
     MandatoryOff("mode.vector.simplify");
     DisableParameter("mode.vector.simplify");
--- otb.orig/Modules/Applications/AppStereo/app/otbBlockMatching.cxx
+++ otb/Modules/Applications/AppStereo/app/otbBlockMatching.cxx
@@ -127,11 +127,11 @@
     SetDescription("Performs block-matching to estimate pixel-wise disparities between two images");
 
     SetDocName("Pixel-wise Block-Matching");
-    SetDocLongDescription("This application allows to performs block-matching to estimate pixel-wise disparities "
-      "between two images. The application allows to choose the block-matching method to use. It also allows to input"
+    SetDocLongDescription("This application allows one to performs block-matching to estimate pixel-wise disparities "
+      "between two images. The application allows one to choose the block-matching method to use. It also allows one to input"
       " masks (related to the left and right input image) of pixels for which the disparity should be investigated. "
       "Additionally, two criteria can be optionally used to disable disparity investigation for some pixel: a "
-      "no-data value, and a threshold on the local variance. This allows to speed-up computation by avoiding to "
+      "no-data value, and a threshold on the local variance. This allows one to speed-up computation by avoiding to "
       "investigate disparities that will not be reliable anyway. For efficiency reasons, if the optimal metric values"
       " image is desired, it will be concatenated to the output image (which will then have three bands : horizontal "
       "disparity, vertical disparity and metric value). One can split these images afterward.");
@@ -142,7 +142,7 @@
     AddDocTag(Tags::Stereo);
 
     AddParameter(ParameterType_Group,"io","Input and output data");
-    SetParameterDescription("io","This group of parameters allows to set the input and output images.");
+    SetParameterDescription("io","This group of parameters allows one to set the input and output images.");
 
     AddParameter(ParameterType_InputImage,"io.inleft","Left input image");
     SetParameterDescription("io.inleft","The left input image (reference)");
@@ -163,24 +163,24 @@
     SetParameterDescription("io.outmetric","If used, the output image will have a second component with metric optimal values");
 
     AddParameter(ParameterType_Group,"mask","Image masking parameters");
-    SetParameterDescription("mask","This group of parameters allows to determine the masking parameters to prevent disparities estimation for some pixels of the left image");
+    SetParameterDescription("mask","This group of parameters allows one to determine the masking parameters to prevent disparities estimation for some pixels of the left image");
 
     AddParameter(ParameterType_InputImage,"mask.inleft","Discard left pixels from mask image");
-    SetParameterDescription("mask.inleft","This parameter allows to provide a custom mask for the left image.Block matching will be only perform on pixels inside the mask.");
+    SetParameterDescription("mask.inleft","This parameter allows one to provide a custom mask for the left image.Block matching will be only perform on pixels inside the mask.");
     MandatoryOff("mask.inleft");
 
     AddParameter(ParameterType_InputImage,"mask.inright","Discard right pixels from mask image");
-    SetParameterDescription("mask.inright","This parameter allows to provide a custom mask for the right image.Block matching will be perform only on pixels inside the mask.");
+    SetParameterDescription("mask.inright","This parameter allows one to provide a custom mask for the right image.Block matching will be perform only on pixels inside the mask.");
     MandatoryOff("mask.inright");
 
     AddParameter(ParameterType_Float,"mask.nodata","Discard pixels with no-data value");
-    SetParameterDescription("mask.nodata","This parameter allows to discard pixels whose value is equal to the user-defined no-data value.");
+    SetParameterDescription("mask.nodata","This parameter allows one to discard pixels whose value is equal to the user-defined no-data value.");
     MandatoryOff("mask.nodata");
     SetDefaultParameterFloat("mask.nodata",0.);
     DisableParameter("mask.nodata");
 
     AddParameter(ParameterType_Float,"mask.variancet","Discard pixels with low local variance");
-    SetParameterDescription("mask.variancet","This parameter allows to discard pixels whose local variance is too small (the size of the neighborhood is given by the radius parameter)");
+    SetParameterDescription("mask.variancet","This parameter allows one to discard pixels whose local variance is too small (the size of the neighborhood is given by the radius parameter)");
     MandatoryOff("mask.variancet");
     SetDefaultParameterFloat("mask.variancet",100.);
     DisableParameter("mask.variancet");
--- otb.orig/Modules/Applications/AppStereo/app/otbDisparityMapToElevationMap.cxx
+++ otb/Modules/Applications/AppStereo/app/otbDisparityMapToElevationMap.cxx
@@ -76,7 +76,7 @@
     AddDocTag(Tags::Stereo);
 
     AddParameter(ParameterType_Group,"io","Input and output data");
-    SetParameterDescription("io","This group of parameters allows to set the input and output images and grids.");
+    SetParameterDescription("io","This group of parameters allows one to set the input and output images and grids.");
 
     AddParameter(ParameterType_InputImage,"io.in","Input disparity map");
     SetParameterDescription("io.in","The input disparity map (horizontal disparity in first band, vertical in second)");
--- otb.orig/Modules/Applications/AppStereo/app/otbStereoFramework.cxx
+++ otb/Modules/Applications/AppStereo/app/otbStereoFramework.cxx
@@ -341,7 +341,7 @@
 
     // Add the output paramters in a group
     AddParameter(ParameterType_Group, "input", "Input parameters");
-    SetParameterDescription("input","This group of parameters allows to parametrize input data.");
+    SetParameterDescription("input","This group of parameters allows one to parametrize input data.");
 
     AddParameter(ParameterType_InputImageList,  "input.il",   "Input images list");
     SetParameterDescription("input.il", "The list of images.");
@@ -362,7 +362,7 @@
 
     // Add the output paramters in a group
     AddParameter(ParameterType_Group, "output", "Output parameters");
-    SetParameterDescription("output","This group of parameters allows to choose the DSM resolution, nodata value, and projection parameters.");
+    SetParameterDescription("output","This group of parameters allows one to choose the DSM resolution, nodata value, and projection parameters.");
 
     // // Build the Output Map Projection
     // for custom map projection
@@ -380,7 +380,7 @@
 
     // UserDefined values
     AddParameter(ParameterType_Choice, "output.fusionmethod", "Method to fuse measures in each DSM cell");
-    SetParameterDescription("output.fusionmethod","This parameter allows to choose the method used to fuse elevation measurements in each output DSM cell");
+    SetParameterDescription("output.fusionmethod","This parameter allows one to choose the method used to fuse elevation measurements in each output DSM cell");
     AddChoice("output.fusionmethod.max", "The cell is filled with the maximum measured elevation values");
     AddChoice("output.fusionmethod.min", "The cell is filled with the minimum measured elevation values");
     AddChoice("output.fusionmethod.mean","The cell is filled with the mean of measured elevation values");
@@ -419,7 +419,7 @@
 
     // Add the output paramters in a group
     AddParameter(ParameterType_Group, "stereorect", "Stereorectification Grid parameters");
-    SetParameterDescription("stereorect","This group of parameters allows to choose direct and inverse grid subsampling. These parameters are very useful to tune time and memory consumption.");
+    SetParameterDescription("stereorect","This group of parameters allows one to choose direct and inverse grid subsampling. These parameters are very useful to tune time and memory consumption.");
 
     AddParameter(ParameterType_Int,"stereorect.fwdgridstep","Step of the displacement grid (in pixels)");
     SetParameterDescription("stereorect.fwdgridstep","Stereo-rectification displacement grid only varies slowly. Therefore, it is recommended to use a coarser grid (higher step value) in case of large images");
@@ -427,7 +427,7 @@
     MandatoryOff("stereorect.fwdgridstep");
 
     AddParameter(ParameterType_Int, "stereorect.invgridssrate", "Sub-sampling rate for epipolar grid inversion");
-    SetParameterDescription("stereorect.invgridssrate","Grid inversion is an heavy process that implies spline regression on control points. To avoid eating to much memory, this parameter allows to first sub-sample the field to invert.");
+    SetParameterDescription("stereorect.invgridssrate","Grid inversion is an heavy process that implies spline regression on control points. To avoid eating to much memory, this parameter allows one to first sub-sample the field to invert.");
     SetDefaultParameterInt("stereorect.invgridssrate",10);
     SetMinimumParameterIntValue("stereorect.invgridssrate",1);
     MandatoryOff("stereorect.invgridssrate");
@@ -506,7 +506,7 @@
     DisableParameter("mask.right");
 
     AddParameter(ParameterType_Float,"mask.variancet","Discard pixels with low local variance");
-    SetParameterDescription("mask.variancet","This parameter allows to discard pixels whose local variance is too small (the size of the neighborhood is given by the radius parameter)");
+    SetParameterDescription("mask.variancet","This parameter allows one to discard pixels whose local variance is too small (the size of the neighborhood is given by the radius parameter)");
     MandatoryOff("mask.variancet");
     SetDefaultParameterFloat("mask.variancet",50.);
     //DisableParameter("mask.variancet");
--- otb.orig/Modules/Applications/AppStereo/app/otbStereoRectificationGridGenerator.cxx
+++ otb/Modules/Applications/AppStereo/app/otbStereoRectificationGridGenerator.cxx
@@ -111,7 +111,7 @@
     SetDocSeeAlso("otbGridBasedImageResampling");
 
     AddParameter(ParameterType_Group,"io","Input and output data");
-    SetParameterDescription("io","This group of parameters allows to set the input and output images.");
+    SetParameterDescription("io","This group of parameters allows one to set the input and output images.");
     AddParameter(ParameterType_InputImage,"io.inleft","Left input image");
     SetParameterDescription("io.inleft","The left input image to resample");
 
@@ -155,11 +155,11 @@
     DisableParameter("epi.elevation.avgdem.maxdisp");
 
     AddParameter(ParameterType_Float,"epi.scale","Scale of epipolar images");
-    SetParameterDescription("epi.scale","The scale parameter allows to generated zoomed-in (scale < 1) or zoomed-out (scale > 1) epipolar images.");
+    SetParameterDescription("epi.scale","The scale parameter allows one to generated zoomed-in (scale < 1) or zoomed-out (scale > 1) epipolar images.");
     SetDefaultParameterFloat("epi.scale",1.);
 
     AddParameter(ParameterType_Int,"epi.step","Step of the deformation grid (in nb. of pixels)");
-    SetParameterDescription("epi.step","Stereo-rectification deformation grid only varies slowly. Therefore, it is recommanded to use a coarser grid (higher step value) in case of large images");
+    SetParameterDescription("epi.step","Stereo-rectification deformation grid only varies slowly. Therefore, it is recommended to use a coarser grid (higher step value) in case of large images");
     SetDefaultParameterInt("epi.step",1);
 
     AddParameter(ParameterType_Int,"epi.rectsizex","Rectified image size X");
@@ -175,7 +175,7 @@
     SetParameterRole("epi.baseline", Role_Output);
 
     AddParameter(ParameterType_Group,"inverse","Write inverse fields");
-    SetParameterDescription("inverse","This group of parameter allows to generate the inverse fields as well");
+    SetParameterDescription("inverse","This group of parameter allows one to generate the inverse fields as well");
 
     AddParameter(ParameterType_OutputImage, "inverse.outleft", "Left inverse deformation grid");
     SetParameterDescription("inverse.outleft","The output deformation grid to be used to resample the epipolar left image");
@@ -186,7 +186,7 @@
     MandatoryOff("inverse.outright");
 
     AddParameter(ParameterType_Int, "inverse.ssrate", "Sub-sampling rate for inversion");
-    SetParameterDescription("inverse.ssrate","Grid inversion is an heavy process that implies spline regression on control points. To avoid eating to much memory, this parameter allows to first sub-sample the field to invert.");
+    SetParameterDescription("inverse.ssrate","Grid inversion is an heavy process that implies spline regression on control points. To avoid eating to much memory, this parameter allows one to first sub-sample the field to invert.");
     SetDefaultParameterInt("inverse.ssrate",16);
     SetMinimumParameterIntValue("inverse.ssrate",1);
 
--- otb.orig/Modules/Applications/AppTextures/app/otbHaralickTextureExtraction.cxx
+++ otb/Modules/Applications/AppTextures/app/otbHaralickTextureExtraction.cxx
@@ -90,7 +90,7 @@
 AddRAMParameter();
 
 AddParameter(ParameterType_Group, "parameters", "Texture feature parameters");
-SetParameterDescription("parameters","This group of parameters allows to define texture parameters.");
+SetParameterDescription("parameters","This group of parameters allows one to define texture parameters.");
 
 AddParameter(ParameterType_Int,"parameters.xrad","X Radius");
 SetParameterDescription("parameters.xrad", "X Radius");
--- otb.orig/Modules/Applications/AppTextures/app/otbSFSTextureExtraction.cxx
+++ otb/Modules/Applications/AppTextures/app/otbSFSTextureExtraction.cxx
@@ -81,7 +81,7 @@
 AddRAMParameter();
 
 AddParameter(ParameterType_Group, "parameters", "Texture feature parameters");
-SetParameterDescription("parameters","This group of parameters allows to define SFS texture parameters.\
+SetParameterDescription("parameters","This group of parameters allows one to define SFS texture parameters.\
     The available texture features are SFS'Length, SFS'Width, SFS'PSI, SFS'W-Mean, SFS'Ratio and SFS'SD.\
     They are provided in this exact order in the output image.");
 
--- otb.orig/Modules/Applications/AppVectorDataTranslation/app/otbRasterization.cxx
+++ otb/Modules/Applications/AppVectorDataTranslation/app/otbRasterization.cxx
@@ -63,7 +63,7 @@
     SetDescription("Rasterize a vector dataset.");
 
     SetDocName("Rasterization");
-    SetDocLongDescription("This application allows to reproject and rasterize a vector dataset. The grid of the rasterized output can be set by using a reference image, or by setting all parmeters (origin, size, spacing) by hand. In the latter case, at least the spacing (ground sampling distance) is needed (other parameters are computed automatically). The rasterized output can also be in a different projection reference system than the input dataset.\n There are two rasterize mode available in the application. The first is the binary mode: it allows to render all pixels belonging to a geometry of the input dataset in the foreground color, while rendering the other in background color. The second one allows to render pixels belonging to a geometry woth respect to an attribute of this geometry. The field of the attribute to render can be set by the user. In the second mode, the background value is still used for unassociated pixels.");
+    SetDocLongDescription("This application allows one to reproject and rasterize a vector dataset. The grid of the rasterized output can be set by using a reference image, or by setting all parmeters (origin, size, spacing) by hand. In the latter case, at least the spacing (ground sampling distance) is needed (other parameters are computed automatically). The rasterized output can also be in a different projection reference system than the input dataset.\n There are two rasterize mode available in the application. The first is the binary mode: it allows one to render all pixels belonging to a geometry of the input dataset in the foreground color, while rendering the other in background color. The second one allows one to render pixels belonging to a geometry woth respect to an attribute of this geometry. The field of the attribute to render can be set by the user. In the second mode, the background value is still used for unassociated pixels.");
     SetDocLimitations("None");
     SetDocAuthors("OTB-Team");
     SetDocSeeAlso("For now, support of input dataset with multiple layers having different projection reference system is limited.");
--- otb.orig/Examples/DataRepresentation/Image/VectorImage.cxx
+++ otb/Examples/DataRepresentation/Image/VectorImage.cxx
@@ -40,7 +40,7 @@
 // However, the \doxygen{itk}{Vector} is a fixed size array and it
 // assumes that the number of channels of the image is known at
 // compile time. Therefore, we prefer to use the
-// \doxygen{otb}{VectorImage} class which allows to choose the number
+// \doxygen{otb}{VectorImage} class which allows choosing the number
 // of channels of the image at runtime. The pixels will be of type
 // \doxygen{itk}{VariableLengthVector}.
 //
@@ -91,7 +91,7 @@
   image->SetRegions(region);
 
   // Software Guide : BeginLatex
-  // Since the pixel dimensionality is choosen at runtime, one has to
+  // Since the pixel dimensionality is chosen at runtime, one has to
   // pass this parameter to the image before memory allocation.
   // Software Guide : EndLatex
 
--- otb.orig/Modules/Applications/AppClassification/app/otbComputePolylineFeatureFromImage.cxx
+++ otb/Modules/Applications/AppClassification/app/otbComputePolylineFeatureFromImage.cxx
@@ -76,10 +76,10 @@
   void DoInit()
   {
     SetName("ComputePolylineFeatureFromImage");
-    SetDescription("This application compute for each studied polyline, contained in the input VectorData, the choosen descriptors.");
+    SetDescription("This application compute for each studied polyline, contained in the input VectorData, the chosen descriptors.");
 
     SetDocName("Compute Polyline Feature From Image");
-    SetDocLongDescription("The first step in the classifier fusion based validation is to compute, for each studied polyline, the choosen descriptors. ");
+    SetDocLongDescription("The first step in the classifier fusion based validation is to compute, for each studied polyline, the chosen descriptors. ");
     SetDocLimitations("Since it does not rely on streaming process, take care of the size of input image before launching application.");
     SetDocAuthors("OTB-Team");
     SetDocSeeAlso(" ");
--- otb.orig/Modules/Filtering/ImageManipulation/include/otbPrintableImageFilter.h
+++ otb/Modules/Filtering/ImageManipulation/include/otbPrintableImageFilter.h
@@ -249,7 +249,7 @@
   typename ChannelExtractorType::Pointer m_Extractor;
   // Foreground mask value
   FunctorFilterPointerType m_MaskFilter;
-  // Objects (of the mask) will be displayer with the choosen color.
+  // Objects (of the mask) will be displayer with the chosen color.
   OutputPixelType m_ObjectColor;
   // Use mask
   bool m_UseMask;
--- otb.orig/Modules/Wrappers/ApplicationEngine/src/otbWrapperComplexInputImageParameter.cxx
+++ otb/Modules/Wrappers/ApplicationEngine/src/otbWrapperComplexInputImageParameter.cxx
@@ -42,7 +42,7 @@
 bool
 ComplexInputImageParameter::SetFromFileName(const std::string& filename)
 {
-  // First clear previous file choosen
+  // First clear previous file chosen
   this->ClearValue();
 
   // No file existence is done here :
--- otb.orig/Modules/Wrappers/ApplicationEngine/src/otbWrapperInputImageListParameter.cxx
+++ otb/Modules/Wrappers/ApplicationEngine/src/otbWrapperInputImageListParameter.cxx
@@ -38,7 +38,7 @@
 bool
 InputImageListParameter::SetListFromFileName(const std::vector<std::string> & filenames)
 {
-  // First clear previous file choosen
+  // First clear previous file chosen
   this->ClearValue();
 
   bool isOk = true;
--- otb.orig/Modules/Wrappers/ApplicationEngine/src/otbWrapperInputImageParameter.cxx
+++ otb/Modules/Wrappers/ApplicationEngine/src/otbWrapperInputImageParameter.cxx
@@ -43,7 +43,7 @@
 bool
 InputImageParameter::SetFromFileName(const std::string& filename)
 {
-  // First clear previous file choosen
+  // First clear previous file chosen
   this->ClearValue();
 
   // No file existence is done here :
--- otb.orig/Modules/Wrappers/ApplicationEngine/src/otbWrapperInputVectorDataListParameter.cxx
+++ otb/Modules/Wrappers/ApplicationEngine/src/otbWrapperInputVectorDataListParameter.cxx
@@ -40,7 +40,7 @@
 bool
 InputVectorDataListParameter::SetListFromFileName(const std::vector<std::string> & filenames)
 {
-  // First clear previous file choosen
+  // First clear previous file chosen
   this->ClearValue();
 
   bool isOk = true;
--- otb.orig/Modules/Wrappers/ApplicationEngine/src/otbWrapperInputVectorDataParameter.cxx
+++ otb/Modules/Wrappers/ApplicationEngine/src/otbWrapperInputVectorDataParameter.cxx
@@ -37,7 +37,7 @@
 bool
 InputVectorDataParameter::SetFromFileName(const std::string& filename)
 {
-  // First clear previous file choosen
+  // First clear previous file chosen
   this->ClearValue();
 
   // TODO : when the logger will be available, redirect the exception
--- otb.orig/Examples/DataRepresentation/Mesh/PointSetWithVectors.cxx
+++ otb/Examples/DataRepresentation/Mesh/PointSetWithVectors.cxx
@@ -25,7 +25,7 @@
 //  This example illustrates how a point set can be parameterized to manage a
 //  particular pixel type. It is quite common to associate vector values with
 //  points for producing geometric representations or storing
-//  multi-band informations.  The following code shows
+//  multi-band information.  The following code shows
 //  how vector values can be used as pixel type on the PointSet class.  The
 //  \doxygen{itk}{Vector} class is used here as the pixel type. This class is
 //  appropriate for representing the relative position between two points. It
--- otb.orig/Examples/IO/HDFReaderExample.cxx
+++ otb/Examples/IO/HDFReaderExample.cxx
@@ -36,7 +36,7 @@
 // OTB is using GDAL to support HDF. HDF4 and HDF5 supports in Gdal is
 // not activated by default. You need to download the HDF run-time
 // libraries and compile Gdal by adding the support of these formats. You can
-// find more informations here : \url{http://trac.osgeo.org/gdal/wiki/HDF}
+// find more information here : \url{http://trac.osgeo.org/gdal/wiki/HDF}
 //
 //
 // The first step toward the use of these filters is to include the proper header files.
@@ -87,9 +87,9 @@
 
 // Software Guide : BeginLatex
 //
-// You can access to subdatasets' informations available in the HDF file using
+// You can access to subdatasets' information available in the HDF file using
 // the \code{GetSubDatasetInfo} method of \doxygen{otb}{GDALImageIO}.
-// It allows to store HDF subdatasets names and descriptions in vector of string.
+// It allows storing HDF subdatasets names and descriptions in vector of string.
 // You can find below how to print the name and the decription
 // of all the subdatasets.
 //
--- otb.orig/Examples/IO/ImageToKmzAndMapFileProductExample.cxx
+++ otb/Examples/IO/ImageToKmzAndMapFileProductExample.cxx
@@ -30,7 +30,7 @@
 // and MapFile products.
 // Note that the \doxygen{otb}{KmzProductWriter} and the
 // \doxygen{otb}{MapFileProductWriter} can only process inputs with a
-// non empty geographical informations.
+// non empty geographical information.
 //
 // The first step toward the use of these filters is to include the
 // proper header files: the one for the rpc sensor estimation filter and
@@ -113,7 +113,7 @@
 // or its keywordlist is updated. In general, a dozen of GCPs are
 // needed to estimate an accurate sensor model. The points are added
 // via the method AddGCP(PointType2D, PointType3D). The outpput image
-// obtained have the needed meta-data informations for the rest of the
+// obtained have the needed meta-data information for the rest of the
 // process.
 //
 // Software Guide : EndLatex
--- otb.orig/Examples/Radiometry/AtmosphericCorrectionSequencement.cxx
+++ otb/Examples/Radiometry/AtmosphericCorrectionSequencement.cxx
@@ -302,7 +302,7 @@
 // These {\em containers} will be given to the static function \texttt{Compute}
 // from \doxygen{otb}{RadiometryCorrectionParametersToAtmosphericRadiativeTerms}
 // class, which will call a 6S routine that will compute the needed
-// radiometric informations and store them in a
+// radiometric information and store them in a
 // \doxygen{otb}{AtmosphericRadiativeTerms} class instance.
 // For this,
 // \doxygen{otb}{RadiometryCorrectionParametersToAtmosphericRadiativeTerms},
@@ -461,7 +461,7 @@
   // Software Guide : BeginLatex
   //
   // Once those parameters are loaded, they are used by the 6S library
-  // to compute the needed radiometric informations. The
+  // to compute the needed radiometric information. The
   // RadiometryCorrectionParametersToAtmosphericRadiativeTerms class
   // provides a static function to perform this step\footnote{Before version
   // 4.2, it was done with the filter
@@ -548,7 +548,7 @@
 // Next (and last step) is the neighborhood correction.
 // For this, the SurfaceAdjacencyEffectCorrectionSchemeFilter class is used.
 // The previous surface reflectance inversion is performed under the assumption of a
-// homogeneous ground environment. The following step allows to correct the adjacency
+// homogeneous ground environment. The following step allows correcting the adjacency
 // effect on the radiometry of pixels. The method is based on the decomposition of
 // the observed signal as the summation of the own contribution of the target pixel and
 // of the contributions of neighbored pixels moderated by their distance to the target pixel.
--- otb.orig/Examples/Simulation/ProsailModel.cxx
+++ otb/Examples/Simulation/ProsailModel.cxx
@@ -238,7 +238,7 @@
   //  \item PSI 0
   //  \end{itemize}
   //
-  //  More informations and data about leaf properties can be found at \emph{St\'{e}phane Jacquemoud} \href{http://teledetection.ipgp.jussieu.fr/opticleaf/}{OPTICLEAF} website.
+  //  More information and data about leaf properties can be found at \emph{St\'{e}phane Jacquemoud} \href{http://teledetection.ipgp.jussieu.fr/opticleaf/}{OPTICLEAF} website.
   //  Software Guide : EndLatex
 
   return EXIT_SUCCESS;
--- otb.orig/Modules/Adapters/GdalAdapters/include/otbOGRLayerWrapper.h
+++ otb/Modules/Adapters/GdalAdapters/include/otbOGRLayerWrapper.h
@@ -522,7 +522,7 @@
 
 #if 0
   /** Related DataSource.
-   * Needed to acces OTB meta informations.
+   * Needed to acces OTB meta information.
    */
   DataSourcePtr m_DataSource;
 #endif
--- otb.orig/Modules/Adapters/OSSIMAdapters/include/otbImageKeywordlist.h
+++ otb/Modules/Adapters/OSSIMAdapters/include/otbImageKeywordlist.h
@@ -137,7 +137,7 @@
   virtual void PrintSelf(std::ostream& os, itk::Indent indent) const;
 
 private:
-  /** Geo informations are in this map */
+  /** Geo information are in this map */
   KeywordlistMap m_Keywordlist;
 
 //  char m_Delimiter;
--- otb.orig/Modules/Applications/AppFusion/app/otbBundleToPerfectSensor.cxx
+++ otb/Modules/Applications/AppFusion/app/otbBundleToPerfectSensor.cxx
@@ -154,7 +154,7 @@
     // Setup the DEM Handler
     otb::Wrapper::ElevationParametersHandler::SetupDEMHandlerFromElevationParameters(this,"elev");
 
-    // Set up output image informations
+    // Set up output image information
     FloatVectorImageType::SpacingType spacing = panchro->GetSpacing();
     FloatVectorImageType::IndexType   start = panchro->GetLargestPossibleRegion().GetIndex();
     FloatVectorImageType::SizeType    size = panchro->GetLargestPossibleRegion().GetSize();
--- otb.orig/Modules/Applications/AppImageUtils/app/otbPixelValue.cxx
+++ otb/Modules/Applications/AppImageUtils/app/otbPixelValue.cxx
@@ -148,7 +148,7 @@
 
     SetParameterString("value", oss.str());
 
-    //Display image informations in the dedicated logger
+    //Display image information in the dedicated logger
     otbAppLogINFO( << oss.str() );
   }
 
--- otb.orig/Modules/Core/ObjectList/include/otbImageListToVectorImageFilter.h
+++ otb/Modules/Core/ObjectList/include/otbImageListToVectorImageFilter.h
@@ -68,7 +68,7 @@
 
   /** GenerateOutputInformation
    * Set the number of bands of the output.
-   * Copy informations from the first image of the list if existing.
+   * Copy information from the first image of the list if existing.
    **/
   virtual void GenerateOutputInformation(void);
 
--- otb.orig/Modules/Core/Transform/include/otbGenericRSTransform.txx
+++ otb/Modules/Core/Transform/include/otbGenericRSTransform.txx
@@ -65,7 +65,7 @@
 }
 
 /**
- * Instanciate the transformation according to informations
+ * Instanciate the transformation according to information
  */
 template<class TScalarType, unsigned int NInputDimensions, unsigned int NOutputDimensions>
 void
--- otb.orig/Modules/Filtering/DimensionalityReduction/include/otbEstimateInnerProductPCAImageFilter.h
+++ otb/Modules/Filtering/DimensionalityReduction/include/otbEstimateInnerProductPCAImageFilter.h
@@ -79,7 +79,7 @@
 
   /** GenerateOutputInformation
    * Set the number of bands of the output.
-   * Copy informations from the first image of the list if existing.
+   * Copy information from the first image of the list if existing.
    **/
   virtual void GenerateOutputInformation(void);
 
--- otb.orig/Modules/Filtering/ImageManipulation/include/otbUnaryImageFunctorWithVectorImageFilter.txx
+++ otb/Modules/Filtering/ImageManipulation/include/otbUnaryImageFunctorWithVectorImageFilter.txx
@@ -103,7 +103,7 @@
     OutputPixelType outPixel;
     outPixel.SetSize(inputPtr->GetNumberOfComponentsPerPixel());
     outPixel.Fill(itk::NumericTraits<OutputInternalPixelType>::Zero);
-    // if the input pixel in null, the output is considered as null ( no sensor informations )
+    // if the input pixel in null, the output is considered as null ( no sensor information )
     if (inPixel != nullPixel)
       {
       for (unsigned int j = 0; j < inputPtr->GetNumberOfComponentsPerPixel(); ++j)
--- otb.orig/Modules/Filtering/Projection/include/otbGenericRSResampleImageFilter.h
+++ otb/Modules/Filtering/Projection/include/otbGenericRSResampleImageFilter.h
@@ -32,7 +32,7 @@
  *
  *  This class uses the otb::StreamingResampleImageFilter. It defines
  *  and uses a otb::GenericRSTransform using the input/output coordinate
- *  system informations listed below. This class can resample the input to an
+ *  system information listed below. This class can resample the input to an
  *  output image with the Size/Origin/Spacing/StartIndex defined by
  *  the user. Note that there are no default values for all the
  *  parmeters, so it is mandatory to set correct parameters to have a
--- otb.orig/Modules/Filtering/Projection/include/otbVectorDataProjectionFilter.txx
+++ otb/Modules/Filtering/Projection/include/otbVectorDataProjectionFilter.txx
@@ -262,7 +262,7 @@
 }
 
 /**
- * Instanciate the transformation according to informations
+ * Instanciate the transformation according to information
  */
 template <class TInputVectorData, class TOutputVectorData>
 void
--- otb.orig/Modules/Filtering/Wavelet/include/otbWaveletFilterBank.h
+++ otb/Modules/Filtering/Wavelet/include/otbWaveletFilterBank.h
@@ -216,7 +216,7 @@
 
   /** GenerateOutputInformation
     * Set the size of the output image depending on the decimation factor
-    * Copy informations from the input image if existing.
+    * Copy information from the input image if existing.
     **/
   virtual void GenerateOutputInformation();
 
@@ -401,7 +401,7 @@
 
   /** GenerateOutputInformation
     * Set the size of the output image depending on the decimation factor
-    * Copy informations from the input image if existing.
+    * Copy information from the input image if existing.
     **/
   virtual void GenerateOutputInformation();
 
--- otb.orig/Modules/Filtering/Wavelet/include/otbWaveletPacketTransform.h
+++ otb/Modules/Filtering/Wavelet/include/otbWaveletPacketTransform.h
@@ -325,7 +325,7 @@
 
   /** GenerateOutputInformation
     * Set the size of the output image depending on the decimation factor
-    * Copy informations from the input image if existing.
+    * Copy information from the input image if existing.
     **/
   virtual void GenerateOutputInformation();
 
--- otb.orig/Modules/Filtering/Wavelet/include/otbWaveletTransform.h
+++ otb/Modules/Filtering/Wavelet/include/otbWaveletTransform.h
@@ -308,7 +308,7 @@
 
   /** GenerateOutputInformation
     * Set the size of the output image depending on the decimation factor
-    * Copy informations from the input image if existing.
+    * Copy information from the input image if existing.
     **/
   virtual void GenerateOutputInformation();
 
--- otb.orig/Modules/IO/Carto/include/otbWorldFile.h
+++ otb/Modules/IO/Carto/include/otbWorldFile.h
@@ -28,7 +28,7 @@
 
 /**
  * \class WorldFile
- * \brief Handles the world file that associates geographic informations to png, jpg
+ * \brief Handles the world file that associates geographic information to png, jpg
  *
  *  The world file format is detailed at
  *  http://en.wikipedia.org/wiki/World_file
--- otb.orig/Modules/IO/Carto/src/otbOSMDataToVectorDataGenerator.cxx
+++ otb/Modules/IO/Carto/src/otbOSMDataToVectorDataGenerator.cxx
@@ -193,7 +193,7 @@
           // Get the value of the key
           std::string resultValue = currentTag->Attribute("v");
 
-          // Fill the element informations
+          // Fill the element information
           elementPair.first  = result;
           elementPair.second = resultValue;
 
--- otb.orig/Modules/IO/ExtendedFilename/include/otbExtendedFilenameToReaderOptions.h
+++ otb/Modules/IO/ExtendedFilename/include/otbExtendedFilenameToReaderOptions.h
@@ -30,8 +30,8 @@
  * - &geom : to specify an external geom file
  * - &sdataidx : sub-dataset index for composite files
  * - &resol : resolution factor for jpeg200 files
- * - &skipcarto : switch to skip the cartographic informations
- * - &skipgeom  : switch to skip the geometric informations
+ * - &skipcarto : switch to skip the cartographic information
+ * - &skipgeom  : switch to skip the geometric information
  *
  *  \sa ImageFileReader
  *
--- otb.orig/Modules/IO/IOBSQ/include/otbBSQImageIO.h
+++ otb/Modules/IO/IOBSQ/include/otbBSQImageIO.h
@@ -139,7 +139,7 @@
   BSQImageIO(const Self &); //purposely not implemented
   void operator =(const Self&); //purposely not implemented
 
-  /** Internal method to read header informations */
+  /** Internal method to read header information */
   bool InternalReadHeaderInformation(const std::string& file_name, std::fstream& file, const bool reportError);
 
 #define otbSwappFileOrderToSystemOrderMacro(StrongType, buffer, buffer_size) \
--- otb.orig/Modules/IO/IOBSQ/src/otbBSQImageIO.cxx
+++ otb/Modules/IO/IOBSQ/src/otbBSQImageIO.cxx
@@ -108,7 +108,7 @@
     otbMsgDevMacro(<< "BSQImageIO::CanReadFile() failed header open ! ");
     return false;
     }
-  //Read header informations
+  //Read header information
   bool lResult = InternalReadHeaderInformation(lFileName, header_file, false);
   header_file.close();
   return (lResult);
@@ -231,7 +231,7 @@
     itkExceptionMacro(<< "BSQImageIO::ReadImageInformation() failed header open ! ");
     }
 
-  //Read header informations
+  //Read header information
   InternalReadHeaderInformation(m_FileName, m_HeaderFile, true);
 
   otbMsgDebugMacro(<< "Driver to read: BSQ");
@@ -375,7 +375,7 @@
     }
   file >> m_Dimensions[0];
 
-  //Read "BITS PER PIXEL" informations
+  //Read "BITS PER PIXEL" information
   file >> lString;
   std::string lStrBitsPerPixels(lString);
   file >> lString;
@@ -397,7 +397,7 @@
   int lNbBitsPerPixels;
   file >> lNbBitsPerPixels;
 
-  //Read "SENSCODAGE" informations (optionnal)
+  //Read "SENSCODAGE" information (optionnal)
   file >> lString;
   if (lString.empty() == false)
     {
@@ -616,11 +616,11 @@
   m_HeaderFile <<  "COLUMNS" << std::endl;
   m_HeaderFile << m_Dimensions[0] << std::endl;
 
-  //Write "BITS PER PIXEL" informations
+  //Write "BITS PER PIXEL" information
   m_HeaderFile <<  "BITS PER PIXEL" << std::endl;
   m_HeaderFile << this->GetComponentSize() * 8 << std::endl;
 
-  //Write "SENSCODAGE" informations
+  //Write "SENSCODAGE" information
   m_HeaderFile <<  "SENSCODAGE" << std::endl;
   if (m_ByteOrder == LittleEndian)
     {
--- otb.orig/Modules/IO/IOGDAL/test/otbGDALImageIOTestWriteMetadata.cxx
+++ otb/Modules/IO/IOGDAL/test/otbGDALImageIOTestWriteMetadata.cxx
@@ -564,7 +564,7 @@
                     abyRaster, 128, 128, GDT_Byte, 0, 0 );
 
 
-  // Get some informations from dataset
+  // Get some information from dataset
   infoDatasetCreate->m_Name = "Create";
   infoDatasetCreate->m_ProjRef = static_cast<std::string>(poDstDS->GetProjectionRef());
 
@@ -593,7 +593,7 @@
   if( poDataset == NULL )
      return false;
 
-  // Get some informations from file
+  // Get some information from file
   infoDatasetWR->m_Name = "WR";
   infoDatasetWR->m_ProjRef = static_cast<std::string>(poDataset->GetProjectionRef());
 
--- otb.orig/Modules/IO/IOGDAL/test/otbGDALReadPxlComplex.cxx
+++ otb/Modules/IO/IOGDAL/test/otbGDALReadPxlComplex.cxx
@@ -38,7 +38,7 @@
   // Get Input parameters
   if (argc != 6)
     {
-    std::cout << "Invalid Parameters: " << argv[0] << "<filenameIn> <posX> <posY> <sizeX> <sizeY><ouput filename>" << std::endl;
+    std::cout << "Invalid Parameters: " << argv[0] << "<filenameIn> <posX> <posY> <sizeX> <sizeY><output filename>" << std::endl;
     return EXIT_FAILURE;
     }
   int posX = (int)atoi(argv[2]);
@@ -56,7 +56,7 @@
   if( poDataset == NULL )
      return EXIT_FAILURE;
 
-  // Get some informations from file
+  // Get some information from file
   int nbBand = poDataset->GetRasterCount();
 
   GDALDataType pxlTypeInFile = poDataset->GetRasterBand(1)->GetRasterDataType();
--- otb.orig/Modules/IO/IOLUM/include/otbLUMImageIO.h
+++ otb/Modules/IO/IOLUM/include/otbLUMImageIO.h
@@ -137,7 +137,7 @@
   LUMImageIO(const Self &); //purposely not implemented
   void operator =(const Self&); //purposely not implemented
 
-  /** Internal method to read header informations */
+  /** Internal method to read header information */
   bool InternalReadHeaderInformation(std::fstream& file, const bool reportError);
   /** This method get the LUM type */
   int CaiGetTypeLum(const char *          type_code,
--- otb.orig/Modules/IO/IOLUM/src/otbLUMImageIO.cxx
+++ otb/Modules/IO/IOLUM/src/otbLUMImageIO.cxx
@@ -106,7 +106,7 @@
     return false;
     }
 
-  //Read header informations
+  //Read header information
   bool lResult = InternalReadHeaderInformation(header_file, false);
   header_file.close();
   return (lResult);
@@ -195,7 +195,7 @@
     itkExceptionMacro(<< "LUMImageIO::ReadImageInformation() failed header open ! ");
     }
 
-  //Read header informations
+  //Read header information
   InternalReadHeaderInformation(m_File, true);
 
   otbMsgDebugMacro(<< "Driver to read: LUM");
@@ -227,7 +227,7 @@
     {
     if (reportError == true)
       {
-      itkExceptionMacro(<< "LUM : bad read of header informations");
+      itkExceptionMacro(<< "LUM : bad read of header information");
       }
     else
       {
@@ -300,7 +300,7 @@
   otbSwappFileOrderToSystemOrderMacro(int, &NbCol, 1);
   otbSwappFileOrderToSystemOrderMacro(int, &NbLig, 1);
 
-  //Initialization of image informations
+  //Initialization of image information
   m_Dimensions[0] = NbCol;
   m_Dimensions[1] = NbLig;
   this->SetNumberOfComponents(1);
--- otb.orig/Modules/IO/IOMW/include/otbMWImageIO.h
+++ otb/Modules/IO/IOMW/include/otbMWImageIO.h
@@ -141,7 +141,7 @@
 
   std::string GetExtension(const std::string& filename);
 
-  /** Internal method to read header informations */
+  /** Internal method to read header information */
   bool InternalReadHeaderInformation(std::fstream& file, const bool reportError);
   inline void ByteSplitting(unsigned short a, unsigned short& low, unsigned short& high)
   {
--- otb.orig/Modules/IO/IOMW/src/otbMWImageIO.cxx
+++ otb/Modules/IO/IOMW/src/otbMWImageIO.cxx
@@ -91,7 +91,7 @@
     return false;
     }
 
-  //Read header informations
+  //Read header information
   bool lResult = InternalReadHeaderInformation(header_file, false);
   header_file.close();
   return (lResult);
@@ -172,7 +172,7 @@
     itkExceptionMacro(<< "MWImageIO::ReadImageInformation() failed header open ! ");
     }
 
-  //Read header informations
+  //Read header information
   InternalReadHeaderInformation(m_File, true);
 
   otbMsgDebugMacro(<< "Driver to read: MW");
@@ -227,7 +227,7 @@
 
   SetComponentType(FLOAT);
 
-  //Initialization of image informations
+  //Initialization of image information
   m_Dimensions[0] = NbCol;
   m_Dimensions[1] = NbLig;
   this->SetNumberOfComponents(1);
--- otb.orig/Modules/IO/IORAD/include/otbRADImageIO.h
+++ otb/Modules/IO/IORAD/include/otbRADImageIO.h
@@ -139,7 +139,7 @@
   RADImageIO(const Self &); //purposely not implemented
   void operator =(const Self&); //purposely not implemented
 
-  /** Internal method to read header informations */
+  /** Internal method to read header information */
   bool InternalReadHeaderInformation(const std::string& file_name, std::fstream& file, const bool reportError);
 
 #define otbSwappFileOrderToSystemOrderMacro(StrongType, buffer, buffer_size) \
--- otb.orig/Modules/IO/IORAD/src/otbRADImageIO.cxx
+++ otb/Modules/IO/IORAD/src/otbRADImageIO.cxx
@@ -112,7 +112,7 @@
     return false;
     }
 
-  //Read header informations
+  //Read header information
   bool lResult = InternalReadHeaderInformation(lFileName, header_file, false);
   header_file.close();
   return (lResult);
@@ -236,7 +236,7 @@
     itkExceptionMacro(<< "RADImageIO::ReadImageInformation() failed header open ! ");
     }
 
-  //Read header informations
+  //Read header information
   InternalReadHeaderInformation(m_FileName, m_HeaderFile, true);
 
   otbMsgDebugMacro(<< "Driver to read: RAD");
@@ -416,7 +416,7 @@
       }
     }
 
-  // Read "SENSCODAGE" informations (optionnal)
+  // Read "SENSCODAGE" information (optionnal)
   file >> lString;
   if (lString.empty() == false)
     {
@@ -704,7 +704,7 @@
     }
   m_HeaderFile << m_TypeRAD << std::endl;
 
-  //Write "SENSCODAGE" informations
+  //Write "SENSCODAGE" information
   m_HeaderFile <<  "SENSCODAGE "; // << std::endl;
   if (m_ByteOrder == LittleEndian)
     {
--- otb.orig/Modules/IO/IOTileMap/src/otbTileMapImageIO.cxx
+++ otb/Modules/IO/IOTileMap/src/otbTileMapImageIO.cxx
@@ -209,7 +209,7 @@
   std::ostringstream filename;
   BuildFileName(quad2, filename);
 
-  // Build tile informations
+  // Build tile information
   TileNameAndCoordType lTileInfos;
   lTileInfos.numTileX = numTileX;
   lTileInfos.numTileY = numTileY;
--- otb.orig/Modules/IO/ImageIO/include/otbImageSeriesFileReader.h
+++ otb/Modules/IO/ImageIO/include/otbImageSeriesFileReader.h
@@ -57,7 +57,7 @@
 
   /** Creation through object factory macro */
   itkNewMacro(Self);
-  /** Runtime informations macro */
+  /** Runtime information macro */
   itkTypeMacro(ImageSeriesFileReader, ImageSeriesFileReaderBase);
 
   typedef typename Superclass::OutputImageType        OutputImageType;
@@ -170,7 +170,7 @@
 
   /** Creation through object factory macro */
   itkNewMacro(Self);
-  /** Runtime informations macro */
+  /** Runtime information macro */
   itkTypeMacro(ImageSeriesFileReader, ImageSeriesFileReaderBase);
 
   typedef typename Superclass::OutputImageType        OutputImageType;
@@ -276,7 +276,7 @@
 
   /** Creation through object factory macro */
   itkNewMacro(Self);
-  /** Runtime informations macro */
+  /** Runtime information macro */
   itkTypeMacro(ImageSeriesFileReader, ImageSeriesFileReaderBase);
 
   typedef typename Superclass::OutputImageType        OutputImageType;
@@ -383,7 +383,7 @@
 
   /** Creation through object factory macro */
   itkNewMacro(Self);
-  /** Runtime informations macro */
+  /** Runtime information macro */
   itkTypeMacro(ImageSeriesFileReader, ImageSeriesFileReaderBase);
 
   typedef typename Superclass::OutputImageType        OutputImageType;
--- otb.orig/Modules/IO/ImageIO/include/otbImageSeriesFileReaderBase.h
+++ otb/Modules/IO/ImageIO/include/otbImageSeriesFileReaderBase.h
@@ -71,7 +71,7 @@
 
   /** Creation through object factory macro */
   itkNewMacro(Self);
-  /** Runtime informations macro */
+  /** Runtime information macro */
   itkTypeMacro(ImageSeriesFileReaderBase, ImageListSource);
 
   typedef TImage                                      OutputImageType;
--- otb.orig/Modules/IO/KMZWriter/include/otbKmzProductWriter.h
+++ otb/Modules/IO/KMZWriter/include/otbKmzProductWriter.h
@@ -44,7 +44,7 @@
 
 /** \class KmzProductWriter
  * \brief This class generate a Kmz from one or several input
- * images. The inputs must have a non empty metadata informations.
+ * images. The inputs must have a non empty metadata information.
  *
  * This class writes kmz files, supported by Google Earth. The input
  * must have metadata (a non empty keywordlist)
--- otb.orig/Modules/IO/KMZWriter/include/otbKmzProductWriter.txx
+++ otb/Modules/IO/KMZWriter/include/otbKmzProductWriter.txx
@@ -117,7 +117,7 @@
 
   if(emptyProjRef &&  emptyKWL)
     {
-    itkExceptionMacro(<<"The input image have empty keyword list, please use an image with metadata informations");
+    itkExceptionMacro(<<"The input image have empty keyword list, please use an image with metadata information");
     }
 
   // Continue processing
--- otb.orig/Modules/Learning/LearningBase/include/otbDecisionTree.h
+++ otb/Modules/Learning/LearningBase/include/otbDecisionTree.h
@@ -68,7 +68,7 @@
 
   /** Creation through object factory macro */
   itkNewMacro(Self);
-  /** Runtime informations macro */
+  /** Runtime information macro */
   itkTypeMacro(DecisionTree, DataObject);
 
   typedef typename std::pair< AttributeValueType, DecisionTreeTestType > KeyType;
--- otb.orig/Modules/Learning/SOM/include/otbPeriodicSOM.h
+++ otb/Modules/Learning/SOM/include/otbPeriodicSOM.h
@@ -72,7 +72,7 @@
   /** Creation through object factory macro */
   itkNewMacro(Self);
 
-  /** Runtime informations macro */
+  /** Runtime information macro */
   itkTypeMacro(PeriodicSOM, SOM);
 
   typedef TListSample                      ListSampleType;
--- otb.orig/Modules/Learning/SOM/include/otbSOM.h
+++ otb/Modules/Learning/SOM/include/otbSOM.h
@@ -68,7 +68,7 @@
 
   /** Creation through object factory macro */
   itkNewMacro(Self);
-  /** Runtime informations macro */
+  /** Runtime information macro */
   itkTypeMacro(SOM, ImageSource);
 
   typedef TListSample                      ListSampleType;
--- otb.orig/Modules/Learning/SOM/include/otbSOMMap.h
+++ otb/Modules/Learning/SOM/include/otbSOMMap.h
@@ -63,7 +63,7 @@
   /** Creation through object factory macro */
   itkNewMacro(Self);
   /**
-   * There is no runtime informations macro since
+   * There is no runtime information macro since
    * this class has to be considered to as a simple VectorImage
    * // itkTypeMacro(SOMMap, VectorImage);
    * */
--- otb.orig/Modules/Learning/SOM/include/otbSOMWithMissingValue.h
+++ otb/Modules/Learning/SOM/include/otbSOMWithMissingValue.h
@@ -72,7 +72,7 @@
 
   /** Creation through object factory macro */
   itkNewMacro(Self);
-  /** Runtime informations macro */
+  /** Runtime information macro */
   itkTypeMacro(SOMWithMissingValue, PeriodicSOM);
 
 protected:
--- otb.orig/Modules/Learning/SVMLearning/include/otbSVMImageClassificationWithRuleFilter.h
+++ otb/Modules/Learning/SVMLearning/include/otbSVMImageClassificationWithRuleFilter.h
@@ -95,7 +95,7 @@
 
   /** GenerateOutputInformation
         * Set the number of bands of the output rule image.
-        * Copy informations from the input image if existing.
+        * Copy information from the input image if existing.
         **/
   virtual void GenerateOutputInformation();
 
--- otb.orig/Modules/OBIA/RCC8/include/otbRCC8GraphFileReader.h
+++ otb/Modules/OBIA/RCC8/include/otbRCC8GraphFileReader.h
@@ -71,7 +71,7 @@
   typedef itk::SmartPointer<const Self> ConstPointer;
   /** Creation through the object factory */
   itkNewMacro(Self);
-  /** Runtime type informations */
+  /** Runtime type information */
   itkTypeMacro(RCC8GraphFileReader, RCC8GraphSource);
   /** Output related typedefs */
   typedef TOutputGraph                                OutputGraphType;
@@ -93,12 +93,12 @@
   /** Main computation method */
   virtual void GenerateData();
   /**
-   * Parse edge informations from a given line.
+   * Parse edge information from a given line.
    * \param line The line to parse.
    */
   void ParseEdge(const std::string& line);
   /**
-   * Parse vertex informations from a given line.
+   * Parse vertex information from a given line.
    * \param line The line to parse.
    */
   void  ParseVertex(const std::string& line);
--- otb.orig/Modules/OBIA/RCC8/include/otbRCC8GraphFileReader.txx
+++ otb/Modules/OBIA/RCC8/include/otbRCC8GraphFileReader.txx
@@ -45,7 +45,7 @@
 {
 }
 /**
- * Parse edge informations from a given line.
+ * Parse edge information from a given line.
  * \param line The line to parse.
  */
 template <class TOutputGraph>
@@ -66,7 +66,7 @@
   this->GetOutput()->AddEdge(source, target, value);
 }
 /**
- * Parse vertex informations from a given line.
+ * Parse vertex information from a given line.
  * \param line The line to parse.
  */
 template <class TOutputGraph>
--- otb.orig/Modules/Radiometry/OpticalCalibration/include/otbAeronetFileReader.h
+++ otb/Modules/Radiometry/OpticalCalibration/include/otbAeronetFileReader.h
@@ -82,7 +82,7 @@
   typedef itk::SmartPointer<const Self> ConstPointer;
   /** Creation through the object factory */
   itkNewMacro(Self);
-  /** Runtime type informations */
+  /** Runtime type information */
   itkTypeMacro(AeronetFileReader, itk::ProcessObject);
 
   /** Overiding of the GetOutput() method */
--- otb.orig/Modules/Radiometry/OpticalCalibration/src/otbAeronetFileReader.cxx
+++ otb/Modules/Radiometry/OpticalCalibration/src/otbAeronetFileReader.cxx
@@ -237,7 +237,7 @@
     return;
     }
 
-  // Read informations lines (5 lines)
+  // Read information lines (5 lines)
   std::getline(fin, line);
   std::getline(fin, line);
   std::getline(fin, line);
--- otb.orig/Modules/Radiometry/Simulation/include/otbSpectralResponse.txx
+++ otb/Modules/Radiometry/Simulation/include/otbSpectralResponse.txx
@@ -49,7 +49,7 @@
     }
 
   int NumLigne = 26; // Go to the line 27
-  //Ignore first 26th lines which are metadatas informations
+  //Ignore first 26th lines which are metadatas information
   for (int i = 0; i < NumLigne; ++i)
     fin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
 
--- otb.orig/Modules/Segmentation/Conversion/include/otbOGRDataSourceToLabelImageFilter.h
+++ otb/Modules/Segmentation/Conversion/include/otbOGRDataSourceToLabelImageFilter.h
@@ -43,7 +43,7 @@
  *  Please note that the background value is also used in
  *  BurnAttributeModeOn() to fill areas where there are no geometries.
  *
- *  Setting the output raster informations can be done in two ways by:
+ *  Setting the output raster information can be done in two ways by:
  *    - Setting the Origin/Size/Spacing of the output image
  *    - Using an existing image as support via SetOutputParametersFromImage(ImageBase)
  *
--- otb.orig/Modules/Segmentation/Conversion/include/otbVectorDataToLabelImageFilter.h
+++ otb/Modules/Segmentation/Conversion/include/otbVectorDataToLabelImageFilter.h
@@ -37,7 +37,7 @@
  *  output raster.  The burn values are extracted from a field set by
  *  the user.If no burning field is set, the "FID" is used by default.
  *
- *  Setting the output raster informations can be done in two ways by:
+ *  Setting the output raster information can be done in two ways by:
  *    - Setting the Origin/Size/Spacing of the output image
  *    - Using an existing image as support via SetOutputParametersFromImage(ImageBase)
  *
--- otb.orig/Modules/Segmentation/MorphologicalProfiles/include/otbMorphologicalClosingProfileFilter.h
+++ otb/Modules/Segmentation/MorphologicalProfiles/include/otbMorphologicalClosingProfileFilter.h
@@ -38,7 +38,7 @@
  * The opening profile is a set of images beeing the result of a geodesic morphological
  * closing by reconstruction with an increasing range of structuring element sizes.
  *
- * For more informations on profiles please refer to the documentation of the otb::ImageToProfileFilter
+ * For more information on profiles please refer to the documentation of the otb::ImageToProfileFilter
  * class.
  *
  * \sa ImageToProfileFilter
--- otb.orig/Modules/Segmentation/MorphologicalProfiles/include/otbMorphologicalOpeningProfileFilter.h
+++ otb/Modules/Segmentation/MorphologicalProfiles/include/otbMorphologicalOpeningProfileFilter.h
@@ -38,7 +38,7 @@
  * The opening profile is a set of images beeing the result of a geodesic morphological
  * opening by reconstruction with an increasing range of structuring element sizes.
  *
- * For more informations on profiles please refer to the documentation of the otb::ImageToProfileFilter
+ * For more information on profiles please refer to the documentation of the otb::ImageToProfileFilter
  * class.
  *
  * \sa ImageToProfileFilter
--- otb.orig/Modules/Segmentation/MorphologicalProfiles/include/otbProfileDerivativeToMultiScaleCharacteristicsFilter.h
+++ otb/Modules/Segmentation/MorphologicalProfiles/include/otbProfileDerivativeToMultiScaleCharacteristicsFilter.h
@@ -87,7 +87,7 @@
 
   /** GenerateOutputInformation
    * Set the number of bands of the output.
-   * Copy informations from the first image of the list if existing.
+   * Copy information from the first image of the list if existing.
    **/
   virtual void GenerateOutputInformation(void);
 
--- otb.orig/Modules/Applications/AppDimensionalityReduction/app/otbDimensionalityReduction.cxx
+++ otb/Modules/Applications/AppDimensionalityReduction/app/otbDimensionalityReduction.cxx
@@ -139,7 +139,7 @@
     AddChoice("method.maf", "MAF");
     SetParameterDescription("method.maf", "Maximum Autocorrelation Factor.");
     AddChoice("method.ica", "ICA");
-    SetParameterDescription("method.ica", "Independant Component Analysis.");
+    SetParameterDescription("method.ica", "Independent Component Analysis.");
     AddParameter(ParameterType_Int, "method.ica.iter", "number of iterations ");
     SetMinimumParameterIntValue("method.ica.iter", 1);
     SetDefaultParameterInt("method.ica.iter", 20);
--- otb.orig/Modules/Applications/AppVectorUtils/app/otbOSMDownloader.cxx
+++ otb/Modules/Applications/AppVectorUtils/app/otbOSMDownloader.cxx
@@ -53,7 +53,7 @@
     SetDescription("Generate a vector data from OSM on the input image extend");
     // Documentation
     SetDocName("Open Street Map layers importations applications");
-    SetDocLongDescription("Generate a vector data from Open Street Map data. A DEM could be use. By default, the entire layer is downloaded, an image can be use as support for the OSM data. The application can provide also available classes in layers . This application required an Internet access. Informations about the OSM project : http://www.openstreetmap.fr/");
+    SetDocLongDescription("Generate a vector data from Open Street Map data. A DEM could be use. By default, the entire layer is downloaded, an image can be use as support for the OSM data. The application can provide also available classes in layers . This application required an Internet access. Information about the OSM project : http://www.openstreetmap.fr/");
     SetDocLimitations("None");
     SetDocAuthors("OTB-Team");
     SetDocSeeAlso("Convertion");
--- otb.orig/Modules/Filtering/DimensionalityReduction/otb-module.cmake
+++ otb/Modules/Filtering/DimensionalityReduction/otb-module.cmake
@@ -2,7 +2,7 @@
 concentrates the amount of information in multivariate data into a fewer number of
 variables (or dimensions). This module implements methods such as Principal Component
 Analysis (PCA), Noise-Adjusted Principal Components Analysis (NAPCA), Maximum
-Noise Fraction (MNF), Fast Independant Component Analysis (FICA), Maximum
+Noise Fraction (MNF), Fast Independent Component Analysis (FICA), Maximum
 Autocorrelation Factor (MAF), and so on.")
 
 otb_module(OTBDimensionalityReduction
--- otb.orig/Examples/BasicFilters/BandMathFilterExample.cxx
+++ otb/Examples/BasicFilters/BandMathFilterExample.cxx
@@ -151,7 +151,7 @@
 //
 //  Now we can define the mathematical expression to perform on the layers (b1, b2, b3, b4).
 //  The filter takes advantage of the parsing capabilities of the muParser library and
-//  allows to set the expression as on a digital calculator.
+//  allows setting the expression as on a digital calculator.
 //
 //  The expression below returns 255 if the ratio $(NIR-RED)/(NIR+RED)$ is greater than 0.4 and 0 if not.
 //
--- otb.orig/Examples/ChangeDetection/ChangeDetectionFrameworkExample.cxx
+++ otb/Examples/ChangeDetection/ChangeDetectionFrameworkExample.cxx
@@ -51,7 +51,7 @@
 // something accepting the syntax \code{foo()}. This can be
 // implemented using classical C/C++ functions, but it is preferable
 // to implement it using C++ functors. These are classical C++ classes
-// which overload the \code{()} operator. This allows to use them with
+// which overload the \code{()} operator. This allows using them with
 // the same syntax as C/C++ functions.
 //
 // Since change detectors operate on neighborhoods, the functor
--- otb.orig/Examples/ChangeDetection/MultivariateAlterationDetector.cxx
+++ otb/Examples/ChangeDetection/MultivariateAlterationDetector.cxx
@@ -32,8 +32,8 @@
 // This example illustrates the class
 // \doxygen{otb}{MultivariateAlterationChangeDetectorImageFilter},
 // which implements the Multivariate Alteration Change Detector
-// algorithm \cite{nielsen2007regularized}. This algorihtm allows to
-// perform change detection from a pair multi-band images, including
+// algorithm \cite{nielsen2007regularized}. This algorihtm allows
+// performing change detection from a pair multi-band images, including
 // images with different number of bands or modalities. Its output is
 // a a multi-band image of change maps, each one being unccorrelated
 // with the remaining. The number of bands of the output image is the
--- otb.orig/Examples/FeatureExtraction/AlignmentsExample.cxx
+++ otb/Examples/FeatureExtraction/AlignmentsExample.cxx
@@ -26,7 +26,7 @@
 // Software Guide : BeginLatex
 //
 // This example illustrates the use of the \doxygen{otb}{ImageToPathListAlignFilter}.
-// This filter allows to extract meaninful alignments. Alignments
+// This filter allows extracting meaninful alignments. Alignments
 // (that is edges and lines) are detected using the {\em Gestalt}
 // approach proposed by Desolneux et al. \cite{desolneux}. In this
 // context, an event is
--- otb.orig/Examples/Filtering/RasterizationExample.cxx
+++ otb/Examples/Filtering/RasterizationExample.cxx
@@ -24,7 +24,7 @@
 
 // Software Guide : BeginLatex
 //
-// The \doxygen{otb}{VectorDataToMapFilter} allows to perform
+// The \doxygen{otb}{VectorDataToMapFilter} allows performing
 // rasterization of a given vector data as a binary mask. This example
 // will demonstrate how to use this filter to perform rasterization of
 // the SRTM water body masks available here:
--- otb.orig/Examples/IO/DEMHandlerExample.cxx
+++ otb/Examples/IO/DEMHandlerExample.cxx
@@ -68,9 +68,9 @@
 
 // Software Guide : BeginLatex
 //
-// It allows to configure a directory containing DEM tiles (DTED or SRTM
+// It allows configuring a directory containing DEM tiles (DTED or SRTM
 // supported) using the \code{OpenDEMDirectory()} method. The \code{OpenGeoidFile()} method
-// allows to input a geoid file as well. Last, a default height above ellipsoid
+// allows inputting a geoid file as well. Last, a default height above ellipsoid
 // can be set using the \code{SetDefaultHeightAboveEllipsoid()} method.
 //
 // Software Guide : EndLatex
--- otb.orig/Examples/IO/ImageReadRegionOfInterestWrite.cxx
+++ otb/Examples/IO/ImageReadRegionOfInterestWrite.cxx
@@ -93,8 +93,8 @@
   //
   //  The ExtractROI type is instantiated using
   //  the input and output pixel types. Using the pixel types as
-  //  template parameters instead of the image types allows to
-  //  restrict the use of this class to \doxygen{otb}{Image}s which
+  //  template parameters instead of the image types allows
+  //  restricting the use of this class to \doxygen{otb}{Image}s which
   //  are used with scalar pixel types. See section
   //  \ref{sec:ExtractROI} for the extraction of ROIs on
   //  \doxygen{otb}{VectorImage}s. A filter object is created with the
--- otb.orig/Examples/Learning/TrainMachineLearningModelFromImagesExample.cxx
+++ otb/Examples/Learning/TrainMachineLearningModelFromImagesExample.cxx
@@ -178,7 +178,7 @@
 // \subdoxygen{itk}{Statistics}{ListSample} as input and estimates the label of each
 // input sample using the model. Finally, the
 // \doxygen{otb}{ImageClassificationModel} inherits from the
-// \doxygen{itk}{ImageToImageFilter} and allows to classify pixels in the
+// \doxygen{itk}{ImageToImageFilter} and allows classifying pixels in the
 // input image by predicting their labels using a model.
 //
 // Software Guide : EndLatex
--- otb.orig/Examples/OBIA/HooverMetricsEstimation.cxx
+++ otb/Examples/OBIA/HooverMetricsEstimation.cxx
@@ -78,7 +78,7 @@
   // Software Guide : BeginLatex
   // The filters \doxygen{otb}{HooverMatrixFilter} and \doxygen{otb}{HooverInstanceFilter}
   // are designed to handle \doxygen{itk}{LabelMap} images, made with \doxygen{otb}{AttributesMapLabelObject}.
-  // This type of label object allows to store generic attributes. Each region can store
+  // This type of label object allows storing generic attributes. Each region can store
   // a set of attributes: in this case, Hoover instances and metrics will be stored.
   // Software Guide : EndLatex
 
--- otb.orig/Modules/Adapters/OSSIMAdapters/include/otbDEMHandler.h
+++ otb/Modules/Adapters/OSSIMAdapters/include/otbDEMHandler.h
@@ -46,13 +46,13 @@
  * configured by this class and this will ensure consistency
  * throughout the library.
  *
- * The class allows to configure a directory containing DEM tiles
+ * The class allows configuring a directory containing DEM tiles
  * (DTED or SRTM supported) using the OpenDEMDirectory() method. The
- * OpenGeoidFile() method allows to input a geoid file as well. Last,
+ * OpenGeoidFile() method allows inputting a geoid file as well. Last,
  * a default height above ellipsoid can be set using the
  * SetDefaultHeightAboveEllipsoid() method.
  *
- * The class allows to retrieve either height above ellipsoid or
+ * The class allows retrieving either height above ellipsoid or
  * height above Mean Sea Level (MSL).
  *
  * Here is the complete description of both methods output depending
--- otb.orig/Modules/Core/Common/include/otbModelComponentBase.txx
+++ otb/Modules/Core/Common/include/otbModelComponentBase.txx
@@ -187,7 +187,7 @@
 ::GenerateData()
 {
   /** subclasses should override this function to perform
-   *  parameter estimation. But it allows to switch m_SampleModified
+   *  parameter estimation. But it allows switching m_SampleModified
    *  when necessary.
    */
   m_SampleModified = 0;
--- otb.orig/Modules/Core/Common/include/otbSubsampledImageRegionConstIterator.h
+++ otb/Modules/Core/Common/include/otbSubsampledImageRegionConstIterator.h
@@ -71,7 +71,7 @@
    * it needs to be redone here for this subclass to compile properly with gcc. */
   typedef typename Superclass::ImageType ImageType;
 
-  /** Offset typedef support. This explicit redefinition allows to Set/Get
+  /** Offset typedef support. This explicit redefinition allows Setting/Getting
    * the location of the iterator. */
   //typedef typename Superclass::OffsetType OffsetType;
   typedef unsigned long OffsetType;
--- otb.orig/Modules/Core/ImageBase/include/otbMetaImageFunction.h
+++ otb/Modules/Core/ImageBase/include/otbMetaImageFunction.h
@@ -29,7 +29,7 @@
 /** \class MetaImageFunction
  *  \brief Concatenate results from multiple ImageFunction
  *
- *  The MetaImageFunction class allows to call multiple ImageFunction at the same location
+ *  The MetaImageFunction class allows calling multiple ImageFunction at the same location
  *  and to concatenate their result into a single VariableLengthVector.
  *
  *  In the case of ImageFunction which do not produce VariableLengthVector, one can wrap these
--- otb.orig/Modules/Core/ImageBase/include/otbMultiChannelExtractROI.h
+++ otb/Modules/Core/ImageBase/include/otbMultiChannelExtractROI.h
@@ -31,7 +31,7 @@
  * \brief Extract a spatial or spectral subset of a multi-channel image.
  *
  * It is possible to extract all the channels from the input image or only those specified by the user.
- * The SetChannel() method allows to select one channel.
+ * The SetChannel() method allows selecting one channel.
  * The SetFirstChannel() and SetLastChannel() methods allow the user to define a list of channels.
  *
  * \note If no channels are specified, then all channels from the input image are selected.
--- otb.orig/Modules/Core/ImageBase/include/otbMultiToMonoChannelExtractROI.h
+++ otb/Modules/Core/ImageBase/include/otbMultiToMonoChannelExtractROI.h
@@ -31,7 +31,7 @@
  * \brief Extract a mono channel part of a multi-channel image.
  *
  * This filter extracts either all channels or only those specified by the user.
- * The SetChannel method allows to select the channels to process.
+ * The SetChannel method allows selecting the channels to process.
  * \note If nothing is specified, only the first channel is processed.
  * \note This class is templated over the pixel types of the input and output images.
  * The input image has to be an otb::VectorImage, whereas the output image has to be an otb::Image.
--- otb.orig/Modules/Core/LabelMap/include/otbAttributesMapLabelObject.h
+++ otb/Modules/Core/LabelMap/include/otbAttributesMapLabelObject.h
@@ -37,7 +37,7 @@
 {
 
 /** \class AttributesMapLabelObjectAccessor
- *  \brief Allows to acces a given field of an AttributesMapLabelObject
+ *  \brief Allows accessing a given field of an AttributesMapLabelObject
  *
  * The name of the attribute to retrieve can be set by using the
  * SetAttributeName method.
@@ -88,9 +88,9 @@
 
 
 /** \class AttributesMapMeasurementFunctor
-*   \brief This class allows to build a measurement vector from an AttributesMapLabelObject
+*   \brief This class allows building a measurement vector from an AttributesMapLabelObject
 *
-*    It Allows to select only a subset of the available attributes.
+*    It Allows selecting only a subset of the available attributes.
  *
  * \ingroup OTBLabelMap
 */
@@ -156,7 +156,7 @@
  *  store pairs of key, value (of type TAttributesValue) in an internal
  *  map container.
  *
- * As such it allows to store any custom attributes as necessary.
+ * As such it allows storing any custom attributes as necessary.
  *
  * \sa LabelObject, ShapeLabelObject, StatisticsLabelObject
  *
--- otb.orig/Modules/Core/LabelMap/include/otbAttributesMapOpeningLabelMapFilter.h
+++ otb/Modules/Core/LabelMap/include/otbAttributesMapOpeningLabelMapFilter.h
@@ -28,7 +28,7 @@
  * \brief Attributes opening for AttributesMapLabelObject
  *
  * This class extends the itk::AttributeOpeningLabelMapFilter to
- * handle AttributesMapLabelObject. Thus it allows to perform openings
+ * handle AttributesMapLabelObject. Thus it allows performing openings
  * for any kind of attributes in the attributes map.
  *
  * \sa AttributeLabelObject, AttributeOpeningLabelMapFilter
--- otb.orig/Modules/Core/LabelMap/include/otbBandsStatisticsAttributesLabelMapFilter.h
+++ otb/Modules/Core/LabelMap/include/otbBandsStatisticsAttributesLabelMapFilter.h
@@ -32,7 +32,7 @@
 * StatisticsAttributesLabelObjectFunctor one each feature image
 * provided through AddFeature()
 *
-* As such, it allows to compute in one pass statistics related to
+* As such, it allows computing in one pass statistics related to
 * multiple features. It is used in the
 * BandsStatisticsAttributesLabelMapFilter.
 *
@@ -123,7 +123,7 @@
  * The feature name is constructed as:
  * 'STATS' + '::' + 'Band' + band_index + '::' + statistic_name
  *
- * The ReducedAttributesSet flag allows to tell the internal
+ * The ReducedAttributesSet flag allows telling the internal
  * statistics filter to compute only the main attributes (mean, variance, skewness and kurtosis).
  *
  * \sa MultiStatsAttributesLabelObjectFunctor AttributesMapLabelObject
--- otb.orig/Modules/Core/LabelMap/include/otbLabelMapToSampleListFilter.h
+++ otb/Modules/Core/LabelMap/include/otbLabelMapToSampleListFilter.h
@@ -31,7 +31,7 @@
  * learning and classification.
  *
  * The conversion from label object to measurement vector is made
- * through a functor. This allows to support any kind of LabelObject
+ * through a functor. This allows supporting any kind of LabelObject
  * via proper redefinition of the functor.
  *
  * \ingroup OTBLabelMap
--- otb.orig/Modules/Core/LabelMap/include/otbLabelMapWithClassLabelToLabeledSampleListFilter.h
+++ otb/Modules/Core/LabelMap/include/otbLabelMapWithClassLabelToLabeledSampleListFilter.h
@@ -28,7 +28,7 @@
  * and compatible with otb::SVMSampleListModelEstimator
  *
  * The conversion from label object to measurement vector is made
- * through a functor. This allows to support any kind of LabelObject
+ * through a functor. This allows supporting any kind of LabelObject
  * via proper redefinition of the functor.
  *
  * \sa otb::SVMSampleListModelEstimator
--- otb.orig/Modules/Core/LabelMap/include/otbShapeAttributesLabelMapFilter.h
+++ otb/Modules/Core/LabelMap/include/otbShapeAttributesLabelMapFilter.h
@@ -187,7 +187,7 @@
  * With respect to the original itk filter, this filter also compute
  * the Flusser moments for each LabelObject.
  *
- * The flag ReducedAttributesSet allows to compute only non-redundant
+ * The flag ReducedAttributesSet allows computing only non-redundant
  * statistics and statistics usefull for classification (not spatially
  * dependent statitistics). Reduced set contains only Flusser moments,
  * physical size, elongation, Feret diameter (if activated),
--- otb.orig/Modules/Core/LabelMap/include/otbStatisticsAttributesLabelMapFilter.h
+++ otb/Modules/Core/LabelMap/include/otbStatisticsAttributesLabelMapFilter.h
@@ -113,7 +113,7 @@
  * set. The key of the statistics features in the attributes map will
  * be "STATS::FeatureName::StatisticName".
  *
- * The flag ReducedAttributesSet allows to compute only non-redundant
+ * The flag ReducedAttributesSet allows computing only non-redundant
  * statistics and statistics usefull for classification (not spatially
  * dependent statitistics). Reduced set contains only mean, variance,
  * skewness and kurtosis.
--- otb.orig/Modules/Core/ObjectList/include/otbImageList.h
+++ otb/Modules/Core/ObjectList/include/otbImageList.h
@@ -25,7 +25,7 @@
 /** \class ImageList
  *  \brief This class represent a list of images.
  *
- * It is derived from the otbObjectList class, which allows to manipulate an ITK/OTB
+ * It is derived from the otbObjectList class, which allows manipulating an ITK/OTB
  * object list with the appropriate formalism (iterators, accessors).
  * \sa ObjectList
  *
--- otb.orig/Modules/Core/Streaming/include/otbPipelineMemoryPrintCalculator.h
+++ otb/Modules/Core/Streaming/include/otbPipelineMemoryPrintCalculator.h
@@ -27,18 +27,18 @@
 /** \class PipelineMemoryPrintCalculator
  *  \brief Estimate pipeline memory usage and optimal stream divisions
  *
- *  This class allows to estimate the memory usage of a given pipeline
+ *  This class allows estimating the memory usage of a given pipeline
  *  by tracing back pipeline from a given data (in general, this
  *  data should be set to the data to write) and
  *  examining each filter to determine its memory footprint. To do so,
  *  it performs a dry run of the requested region pipeline
  *  negotiation.
  *
- *  The SetDataToWrite() method allows to set the data candidate for
+ *  The SetDataToWrite() method allows setting the data candidate for
  *  writing, and for which memory usage estimation should be
  *  performed.
  *
- *  Additionally, this class allows to compute the optimal number of
+ *  Additionally, this class allows computing the optimal number of
  *  stream division to write the data. To do so, the available memory
  *  can be set via the SetAvailableMemory() method, and an optional
  *  bias correction factor can be applied to weight the estimate
@@ -55,7 +55,7 @@
  *  within composite filter (because there is no way to trace back to
  *  these internal filters). Therefore, memory usage can be highly
  *  biased depending on the filters in the upstream pipeline. The bias
- *  correction factor parameters allows to compensate this bias to the first
+ *  correction factor parameters allows compensating this bias to the first
  *  order.
  *
  * \ingroup OTBStreaming
@@ -88,7 +88,7 @@
   itkGetMacro(MemoryPrint, MemoryPrintType);
 
   /** Set/Get the bias correction factor which will weight the
-   * estimated memory print (allows to compensate bias between
+   * estimated memory print (allows compensating bias between
    * estimated and real memory print, default is 1., i.e. no correction) */
   itkSetMacro(BiasCorrectionFactor, double);
   itkGetMacro(BiasCorrectionFactor, double);
--- otb.orig/Modules/Core/Streaming/include/otbStreamingImageVirtualWriter.h
+++ otb/Modules/Core/Streaming/include/otbStreamingImageVirtualWriter.h
@@ -29,7 +29,7 @@
  *  \brief This class acts like a StreamingImageFileWriter, but without actually
  *  writing data to the disk.
  *
- *  This allows to stream the whole image through persistent filters such as
+ *  This allows streaming the whole image through persistent filters such as
  *  PersitentStatisticsImageFilter in order to get the global statistics of an image.
  *
  *  This filter is not intended to be used with classic ImageToImageFilter, though it
--- otb.orig/Modules/Core/Transform/include/otbSensorModelBase.h
+++ otb/Modules/Core/Transform/include/otbSensorModelBase.h
@@ -32,7 +32,7 @@
 /** \class SensorModelBase
  *  \brief Base class for the sensor model projection classes.
  *
- *  This class allows to transform a geographic point in (lat, long) to a point
+ *  This class allows transforming a geographic point in (lat, long) to a point
  *  in the sensor geometry.  (lat, lon) -> (i, j) ou (lat, lon, h) -> (i, j)
  *
  * \ingroup Projection
--- otb.orig/Modules/Detection/ObjectDetection/include/otbStandardMetaImageFunctionBuilder.h
+++ otb/Modules/Detection/ObjectDetection/include/otbStandardMetaImageFunctionBuilder.h
@@ -35,7 +35,7 @@
 /** \class StandardMetaImageFunctionBuilder
  *  \brief Build a Standard MetaImageFunction
  *
- *  The StandardMetaImageFunctionBuilder class allows to call multiple
+ *  The StandardMetaImageFunctionBuilder class allows calling multiple
  *  ImageFunctions:
  *    - otbRadiometricMomentsImageFunction
  *    - otbFlusserMomentsImageFunction
--- otb.orig/Modules/Feature/Edge/include/otbPersistentVectorizationImageFilter.h
+++ otb/Modules/Feature/Edge/include/otbPersistentVectorizationImageFilter.h
@@ -33,11 +33,11 @@
 /** \class PersistentVectorizationImageFilter
  *  \brief Perform vectorization in a persistent way.
  *
- * This filter allows to vectorize input labeled image while it is streamed
- * through it. The GetPathList() method allows to get the vectorized boundaries,
- * while the GetOutput() method allows to get the input image itself.
+ * This filter allows vectorizing input labeled image while it is streamed
+ * through it. The GetPathList() method allows getting the vectorized boundaries,
+ * while the GetOutput() method allows getting the input image itself.
  *
- * The Reset() method allows to clear the result  path list.
+ * The Reset() method allows clearing the result path list.
  *
  * \sa PersistentImageFilter
  *
--- otb.orig/Modules/Filtering/ChangeDetection/include/otbMultivariateAlterationDetectorImageFilter.h
+++ otb/Modules/Filtering/ChangeDetection/include/otbMultivariateAlterationDetectorImageFilter.h
@@ -58,7 +58,7 @@
  *
  * The GetV1() and GetV2() methods allow to retrieve the linear
  * combinations used to generate the Mad change maps as a vnl_matrix of
- * double, and the GetRho() method allows to retrieve the correlation
+ * double, and the GetRho() method allows retrieving the correlation
  * associated to each Mad change maps as a vnl_vector.
  *
  * This filter has been implemented from the Matlab code kindly made
--- otb.orig/Modules/Filtering/Convolution/include/otbGaborFilterGenerator.h
+++ otb/Modules/Filtering/Convolution/include/otbGaborFilterGenerator.h
@@ -31,7 +31,7 @@
 {
 
 /** \class GaborFilterGenerator
- * This class allows to generate gabor filter convolution mask. The mask is stored
+ * This class allows generating a gabor filter convolution mask. The mask is stored
  * in a linear buffer of type itk::Array returned by the GetFilter() method.
  *
  * When calling the GetFilter() method, if the filter has to be regenerated, it will be
--- otb.orig/Modules/Filtering/DimensionalityReduction/include/otbMaximumAutocorrelationFactorImageFilter.h
+++ otb/Modules/Filtering/DimensionalityReduction/include/otbMaximumAutocorrelationFactorImageFilter.h
@@ -45,9 +45,9 @@
  * variance. Though the inverse transform can be computed, this filter
  * only provides the forward transform for now.
  *
- * The GetV() method allows to retrieve the linear combinations used
+ * The GetV() method allows retrieving the linear combinations used
  * to generate new variates, and the GetAutoCorrelation() method
- * allows to retrieve the auto-correlation associated to each variate.
+ * allows retrieving the auto-correlation associated to each variate.
  *
  * This filter has been implemented from the Matlab code kindly made
  * available by the authors here:
--- otb.orig/Modules/Filtering/ImageManipulation/include/otbStreamingInnerProductVectorImageFilter.h
+++ otb/Modules/Filtering/ImageManipulation/include/otbStreamingInnerProductVectorImageFilter.h
@@ -140,7 +140,7 @@
 /** \class StreamingInnerProductVectorImageFilter
  * \brief This class streams the whole input image through the PersistentStatisticsImageFilter.
  *
- * This way, it allows to compute the inner product of this image. It calls the
+ * This way, it allows computing the inner product of this image. It calls the
  * Reset() method of the PersistentStatisticsImageFilter before streaming the image and the
  * Synthetize() method of the PersistentStatisticsImageFilter after having streamed the image
  * to compute the statistics. The accessor on the results are wrapping the accessors of the
--- otb.orig/Modules/Filtering/ImageManipulation/include/otbStreamingMatrixTransposeMatrixImageFilter.h
+++ otb/Modules/Filtering/ImageManipulation/include/otbStreamingMatrixTransposeMatrixImageFilter.h
@@ -187,7 +187,7 @@
 /** \class StreamingMatrixTransposeMatrixImageFilter
  * \brief This class streams the whole input image through the PersistentMatrixTransposeMatrixImageFilter.
  *
- * This way, it allows to compute \f[X^T.Y \f] where \f[X\f] and \f[Y\f] are the input images.
+ * This way, it allows computing \f[X^T.Y \f] where \f[X\f] and \f[Y\f] are the input images.
  * first order global statistics of this image. It calls the Reset() method of the
  * PersistentMatrixTransposeMatrixImageFilter before streaming the image and the
  * Synthetize() method of the PersistentMatrixTransposeMatrixImageFilter after having streamed the image
--- otb.orig/Modules/Filtering/ImageManipulation/include/otbStreamingResampleImageFilter.h
+++ otb/Modules/Filtering/ImageManipulation/include/otbStreamingResampleImageFilter.h
@@ -35,12 +35,12 @@
  *         by setting a transform. The filter computes a displacement
  *         grid using the transform set and used it to warp the input.
  *
- * The otb::StreamingResampleImageFilter allows to resample a
+ * The otb::StreamingResampleImageFilter allows resampling a
  * otb::VectorImage using a transformation set with SetTransform()
  * method. First, a displacement grid, with a spacing m_DisplacementGridSpacing
  * and a size relative to this spacing, is built. Then, the image is
- * wraped using this displacement grid. The size (SetOuputSize()), the
- * spacing (SetOuputSpacing()), the start index (SetOutputIndex()) and
+ * wraped using this displacement grid. The size (SetOutputSize()), the
+ * spacing (SetOutputSpacing()), the start index (SetOutputIndex()) and
  * the  interpolator (SetInterpolator()) and the origin (SetOrigin())
  * can be set using the method between brackets.
  *
--- otb.orig/Modules/Filtering/ImageManipulation/include/otbTileImageFilter.h
+++ otb/Modules/Filtering/ImageManipulation/include/otbTileImageFilter.h
@@ -23,11 +23,11 @@
 namespace otb
 {
 /** \class TileImageFilter
- *  \brief This filter allows to make a spatial mosaic from a set of images
+ *  \brief This filter allows making a spatial mosaic from a set of images
  *
  *  This filter produces a spatial mosaic from a set of images. It
  *  supports both otb::Image and otb::VectorImage. The layout
- *  parameter allows to set up of the images will be patched together:
+ *  parameter allows setting up of the images will be patched together:
  *  it is a 2D array containing the number of images in the horizontal
  *  direction and vertical direction respectively.
  *
--- otb.orig/Modules/Filtering/Path/include/otbImageToEdgePathFilter.txx
+++ otb/Modules/Filtering/Path/include/otbImageToEdgePathFilter.txx
@@ -108,7 +108,7 @@
   it.ActivateOffset(RIGHTDOWN);
   it.ActivateOffset(LEFTUP);
   it.ActivateOffset(LEFTDOWN);
-  // The rotation vector allows to get the clock-wise next pixel
+  // The rotation vector allows getting the clock-wise next pixel
   std::vector<typename IteratorType::OffsetType> rotation;
   rotation.push_back(RIGHT);
   rotation.push_back(RIGHTDOWN);
--- otb.orig/Modules/Filtering/Polarimetry/include/otbPolarimetricData.h
+++ otb/Modules/Filtering/Polarimetry/include/otbPolarimetricData.h
@@ -39,7 +39,7 @@
   } ArchitectureType;
 
 /** \class PolarimetricData
-*  \brief This class allows to determine the type of architecture we get.
+*  \brief This class allows determining the type of architecture we get.
 *
 *  HH_HV_VH_VV (0), HH_HV_VV (1), HH_VH_VV (2), HH_HV(3), VH_VV (4), HH_VV (5).
 *
--- otb.orig/Modules/Filtering/Projection/include/otbGCPsToRPCSensorModelImageFilter.h
+++ otb/Modules/Filtering/Projection/include/otbGCPsToRPCSensorModelImageFilter.h
@@ -33,7 +33,7 @@
  * defined GCPs. Internally, it uses an ossimRpcSolver, which performs
  * the estimation using the well known least-square method.
  *
- * The UseImageGCPs flag allows to import GCPs from the image
+ * The UseImageGCPs flag allows importing GCPs from the image
  * metadata, if any.
  *
  * GCPs can be passed to the filter using one of the AddGCP method
--- otb.orig/Modules/Filtering/Projection/include/otbLeastSquareAffineTransformEstimator.h
+++ otb/Modules/Filtering/Projection/include/otbLeastSquareAffineTransformEstimator.h
@@ -36,7 +36,7 @@
  *
  * Tie points can be added through the AddTiePoints() method.
  *
- * The ClearTiePoints() method allows to remove all the tie points
+ * The ClearTiePoints() method allows removing all the tie points
  * that has been previously set.
  *
  * Once all the tie points have been feeded into the estimator, the
--- otb.orig/Modules/Filtering/Projection/include/otbPhysicalToRPCSensorModelImageFilter.h
+++ otb/Modules/Filtering/Projection/include/otbPhysicalToRPCSensorModelImageFilter.h
@@ -36,7 +36,7 @@
  * to estimate a proper RPC sensor model, there are no warning when
  * the model estimated is inaccurate.
  *
- * The UseImageGCPs flag allows to import GCPs from the image
+ * The UseImageGCPs flag allows importing GCPs from the image
  * metadata, if any.(TODO)
  *
  * GCPs can be passed to the filter using one of the AddGCP method
--- otb.orig/Modules/Filtering/Smoothing/include/otbMeanShiftSmoothingImageFilter.h
+++ otb/Modules/Filtering/Smoothing/include/otbMeanShiftSmoothingImageFilter.h
@@ -408,7 +408,7 @@
  * SetSpatialBandwidth()) and within a spectral range (set using
  * SetRangeBandwidth()). The resulting filtered image can be retrieved by
  * GetOutput() or GetRangeOutput(). Parameter SetRangeBandwidthRamp()
- * allows to linearly adapt the range bandwidth to the intensity of
+ * allows linearly adapting the range bandwidth to the intensity of
  * each channel if set greater than 0 (default value is 0).
  *
  * There are additional output images, as explained below.
@@ -544,7 +544,7 @@
   itkGetConstReferenceMacro(BucketOptimization, bool);
 #endif
 
-  /** Global shift allows to tackle down numerical instabilities by
+  /** Global shift allows tackling down numerical instabilities by
   aligning pixel indices when performing tile processing */
   itkSetMacro(GlobalShift,InputIndexType);
 
--- otb.orig/Modules/Filtering/Statistics/include/otbStreamingCompareImageFilter.h
+++ otb/Modules/Filtering/Statistics/include/otbStreamingCompareImageFilter.h
@@ -150,7 +150,7 @@
                              outputRegionForThread,
                              itk::ThreadIdType threadId);
 
-  /** Allows to skip the verification of physical space between
+  /** Allows skipping the verification of physical space between
    *  the two input images (see flag m_PhysicalSpaceCheck)
    */
   virtual void VerifyInputInformation();
@@ -172,7 +172,7 @@
 /** \class StreamingCompareImageFilter
  * \brief This class streams the whole input image through the PersistentCompareImageFilter.
  *
- * This way, it allows to compute estimator on two images. It calls the
+ * This way, it allows computing estimator on two images. It calls the
  * Reset() method of the PersistentCompareImageFilter before streaming the image and the
  * Synthetize() method of the PersistentCompareImageFilter after having streamed the image
  * to compute the estimators. The accessor on the results are wrapping the accessors of the
--- otb.orig/Modules/Filtering/Statistics/include/otbStreamingHistogramVectorImageFilter.h
+++ otb/Modules/Filtering/Statistics/include/otbStreamingHistogramVectorImageFilter.h
@@ -207,7 +207,7 @@
 /** \class StreamingHistogramVectorImageFilter
  * \brief This class streams the whole input image through the PersistentHistogramVectorImageFilter.
  *
- * This way, it allows to compute the min/max of this image. It calls the
+ * This way, it allows computing the min/max of this image. It calls the
  * Reset() method of the PersistentHistogramVectorImageFilter before streaming the image and the
  * Synthetize() method of the PersistentHistogramVectorImageFilter after having streamed the image
  * to compute the statistics. The accessor on the results are wrapping the accessors of the
--- otb.orig/Modules/Filtering/Statistics/include/otbStreamingMinMaxImageFilter.h
+++ otb/Modules/Filtering/Statistics/include/otbStreamingMinMaxImageFilter.h
@@ -158,7 +158,7 @@
 /** \class StreamingMinMaxImageFilter
  * \brief This class streams the whole input image through the PersistentMinMaxImageFilter.
  *
- * This way, it allows to compute the minimum and maximum of this image.
+ * This way, it allows computing the minimum and maximum of this image.
  *
  * It calls the Reset() method of the PersistentMinMaxImageFilter before streaming
  * the image and the Synthetize() method of the PersistentMinMaxImageFilter after
--- otb.orig/Modules/Filtering/Statistics/include/otbStreamingMinMaxVectorImageFilter.h
+++ otb/Modules/Filtering/Statistics/include/otbStreamingMinMaxVectorImageFilter.h
@@ -177,7 +177,7 @@
 /** \class StreamingMinMaxVectorImageFilter
  * \brief This class streams the whole input image through the PersistentMinMaxVectorImageFilter.
  *
- * This way, it allows to compute the min/max of this image. It calls the
+ * This way, it allows computing the min/max of this image. It calls the
  * Reset() method of the PersistentMinMaxVectorImageFilter before streaming the image and the
  * Synthetize() method of the PersistentMinMaxVectorImageFilter after having streamed the image
  * to compute the statistics. The accessor on the results are wrapping the accessors of the
--- otb.orig/Modules/Filtering/Statistics/include/otbStreamingStatisticsImageFilter.h
+++ otb/Modules/Filtering/Statistics/include/otbStreamingStatisticsImageFilter.h
@@ -196,7 +196,7 @@
 /** \class StreamingStatisticsImageFilter
  * \brief This class streams the whole input image through the PersistentStatisticsImageFilter.
  *
- * This way, it allows to compute the first order global statistics of this image. It calls the
+ * This way, it allows computing the first order global statistics of this image. It calls the
  * Reset() method of the PersistentStatisticsImageFilter before streaming the image and the
  * Synthetize() method of the PersistentStatisticsImageFilter after having streamed the image
  * to compute the statistics. The accessor on the results are wrapping the accessors of the
--- otb.orig/Modules/Filtering/Statistics/include/otbStreamingStatisticsMapFromLabelImageFilter.h
+++ otb/Modules/Filtering/Statistics/include/otbStreamingStatisticsMapFromLabelImageFilter.h
@@ -153,7 +153,7 @@
  *
  * This class streams the whole input image through the PersistentStreamingStatisticsMapFromLabelImageFilter.
  *
- * This way, it allows to compute the first order global statistics of this image.
+ * This way, it allows computing the first order global statistics of this image.
  * It calls the Reset() method of the PersistentStatisticsImageFilter before streaming
  * the image and the Synthetize() method of the PersistentStatisticsImageFilter
  * after having streamed the image to compute the statistics.
--- otb.orig/Modules/Filtering/Statistics/include/otbStreamingStatisticsVectorImageFilter.h
+++ otb/Modules/Filtering/Statistics/include/otbStreamingStatisticsVectorImageFilter.h
@@ -252,7 +252,7 @@
 /** \class StreamingStatisticsVectorImageFilter
  * \brief This class streams the whole input image through the PersistentStatisticsImageFilter.
  *
- * This way, it allows to compute the first and second order global statistics of this image. It calls the
+ * This way, it allows computing the first and second order global statistics of this image. It calls the
  * Reset() method of the PersistentStreamingStatisticsVectorImageFilter before streaming the image and the
  * Synthetize() method of the PersistentStreamingStatisticsVectorImageFilter after having streamed the image
  * to compute the statistics. The accessor on the results are wrapping the accessors of the
--- otb.orig/Modules/Filtering/Statistics/include/otbVectorImageToMatrixImageFilter.h
+++ otb/Modules/Filtering/Statistics/include/otbVectorImageToMatrixImageFilter.h
@@ -127,7 +127,7 @@
 /** \class VectorImageToMatrixImageFilter
  * \brief This class streams the whole input image through the PersistentStatisticsImageFilter.
  *
- * This way, it allows to compute the first order global statistics of this image. It calls the
+ * This way, it allows computing the first order global statistics of this image. It calls the
  * Reset() method of the PersistentStatisticsImageFilter before streaming the image and the
  * Synthetize() method of the PersistentStatisticsImageFilter after having streamed the image
  * to compute the statistics. The accessor on the results are wrapping the accessors of the
--- otb.orig/Modules/IO/Carto/include/otbMapFileProductWriter.h
+++ otb/Modules/IO/Carto/include/otbMapFileProductWriter.h
@@ -46,7 +46,7 @@
  *        on the disk.
  *
  * This filter begins by tiling the input image. An accessor
- * SetTileSize allows to set the size of each tile. For each tile
+ * SetTileSize allows setting the size of each tile. For each tile
  * generated, an entry is added to the shapefile to store the location
  * where the file is saved on the disk.
  * The product generated are a mapfile wich is the configuration file
--- otb.orig/Modules/IO/ImageIO/include/otbImageFileWriter.txx
+++ otb/Modules/IO/ImageIO/include/otbImageFileWriter.txx
@@ -682,7 +682,7 @@
   this->ReleaseInputs();
 
   //Reset global shift on input region (box parameter)
-  //It allows to call multiple update over the writer
+  //It allows calling multiple update over the writer
   m_ShiftOutputIndex.Fill(0);
 }
 
--- otb.orig/Modules/Learning/DempsterShafer/include/otbMassOfBelief.h
+++ otb/Modules/Learning/DempsterShafer/include/otbMassOfBelief.h
@@ -57,20 +57,20 @@
  *  retrieved using the GetMass method. If no mass has been associated
  *  with this element, null is returned.
  *
- *  The Normalize() method allows to normalize all masses so that they
- *  sum to 1. The EstimateUncertainty() method allows to associate to
+ *  The Normalize() method allows normalizing all masses so that they
+ *  sum to 1. The EstimateUncertainty() method allows associating to
  *  the uncertain set (i.e. the universe set) a mass so that all
  *  masses sum to 1.
  *
- *  The GetUniverse() method allows to retrieve the set of all symbols
- *  (i.e. the universal set), while the GetSupport() method allows to
- *  retrieve the set of all elements of the power-set for which a mass
+ *  The GetUniverse() method allows retrieving the set of all symbols
+ *  (i.e. the universal set), while the GetSupport() method allows
+ *  retrieving the set of all elements of the power-set for which a mass
  *  has been associated. This method returns a LabelSetOfSetType,
  *  which is a std::set<std::set<TLabel> >.
  *
  *  The mass function can be optionnaly initialized from a given
  *  universe set by building the power-set and associating a null mass
- *  with every elements of this power-set. This allows to ensure that
+ *  with every elements of this power-set. This allows ensuring that
  *  two mass functions will share the exact same universe and
  *  power-set, but is not mandatory, since mass is supposed to be null
  *  for any set if not stated otherwise.
--- otb.orig/Modules/Learning/SVMLearning/include/otbSVMCrossValidationCostFunction.h
+++ otb/Modules/Learning/SVMLearning/include/otbSVMCrossValidationCostFunction.h
@@ -27,7 +27,7 @@
 /** \class SVMCrossValidationCostFunction
  * \brief This function returns the cross validation accuracy of a SVM model.
  *
- * It allows to perform parameters selection to maximize the
+ * It allows performing parameters selection to maximize the
  * accuracy using ITK optimizers.
  *
  * Given an input SVM model, the number of parameters depends on the
--- otb.orig/Modules/Radiometry/OpticalCalibration/include/otbAtmosphericCorrectionParameters.h
+++ otb/Modules/Radiometry/OpticalCalibration/include/otbAtmosphericCorrectionParameters.h
@@ -143,7 +143,7 @@
 private:
   AtmosphericCorrectionParameters(const Self &); //purposely not implemented
   void operator =(const Self&); //purposely not implemented
-  /** Path to an Aeronet data file, allows to compute aerosol optical and water vapor amounts. */
+  /** Path to an Aeronet data file, allows computing aerosol optical and water vapor amounts. */
   std::string m_AeronetFileName;
   /** Day */
   int m_Day;
--- otb.orig/Modules/Radiometry/OpticalCalibration/include/otbSurfaceAdjacencyEffectCorrectionSchemeFilter.h
+++ otb/Modules/Radiometry/OpticalCalibration/include/otbSurfaceAdjacencyEffectCorrectionSchemeFilter.h
@@ -128,7 +128,7 @@
 /** \class SurfaceAdjacencyEffectCorrectionSchemeFilter
  *  \brief Correct the scheme taking care of the surrounding pixels.
  *
- *   The SurfaceAdjacencyEffectCorrectionSchemeFilter class allows to introduce a neighbor correction to the
+ *   The SurfaceAdjacencyEffectCorrectionSchemeFilter class allows introducing a neighbor correction to the
  *   reflectance estimation. The satelite signal is considered as to be a combinaison of the signal coming from
  *   the target pixel and a weighting of the siganls coming from the neighbor pixels.
  *
--- otb.orig/Modules/Registration/DisparityMap/include/otbFineRegistrationImageFilter.h
+++ otb/Modules/Registration/DisparityMap/include/otbFineRegistrationImageFilter.h
@@ -58,7 +58,7 @@
  * grid step to value higher than 1 (grid step is expressed in terms of number of fixed image pixels).
  * Default value is 1.
  *
- * The FineRegistrationImageFilter allows to use the full range of itk::ImageToImageMetric provided by itk.
+ * The FineRegistrationImageFilter allows using the full range of itk::ImageToImageMetric provided by itk.
  *
  * \example DisparityMap/FineRegistrationImageFilterExample.cxx
  *
--- otb.orig/Modules/Registration/DisparityMap/include/otbPixelWiseBlockMatchingImageFilter.h
+++ otb/Modules/Registration/DisparityMap/include/otbPixelWiseBlockMatchingImageFilter.h
@@ -268,7 +268,7 @@
  *  between the two input images (displacement is given in pixels, from left
  *  image to right image).
  *
- *  Masks are not mandatory. A mask allows to indicate pixels validity in
+ *  Masks are not mandatory. A mask allows indicating pixels validity in
  *  either left or right image. Left and right masks can be used independently.
  *  If masks are used, only pixels whose mask values are strictly positive
  *  will be considered for disparity matching. The other will exhibit a null
--- otb.orig/Modules/Registration/Stereo/include/otbStereoSensorModelToElevationMapFilter.h
+++ otb/Modules/Registration/Stereo/include/otbStereoSensorModelToElevationMapFilter.h
@@ -43,23 +43,23 @@
  * map.
  *
  * Setting-up the elevation exploration range is simple : the
- * LowerElevation and HigherElevation parameters allows to set the
+ * LowerElevation and HigherElevation parameters allows setting the
  * exploration range offsets with respect to the local elevation, and
- * the ElevationStep parameter allows to set the step between
+ * the ElevationStep parameter allows setting the step between
  * candidate elevation. The local elevation can either be constant
  * over the whole scene, or interpolated in a Digital Elevation
- * Model. The latter allows to account for highly varying elevation in
- * large scene, and allows to reduce the elevation exploration
+ * Model. The latter allows accounting for highly varying elevation in
+ * large scene, and allows reducing the elevation exploration
  * range. Please note that one can also use a geoid file along with
  * the DEM.
  *
  * Correlation parameters are as follows :
- * - The radius allows to to tune patches size (default is 3),
- * - The CorrelationThreshold allows to set a threshold bellow which
+ * - The radius allows tuning patches size (default is 3),
+ * - The CorrelationThreshold allows setting a threshold bellow which
  *   correlation is considered to fail. If the correlation maxima is
  *   bellow this threshold, the estimated elevation is
  *   discarded (default is 0.7).
- * - The VarianceThreshold allows to discard master patches for which
+ * - The VarianceThreshold allows discarding master patches for which
  *   variance is too small to yeld reliable correlation. If the
  *   variance of the current master patch lies bellow this threshold, no
  *   elevation exploration is performed at this location (default is 4).
--- otb.orig/Modules/Registration/Stereo/include/otbStereorectificationDisplacementFieldSource.h
+++ otb/Modules/Registration/Stereo/include/otbStereorectificationDisplacementFieldSource.h
@@ -43,8 +43,8 @@
  *  pairs so that the displacement related to the elevation only
  *  occurs in the horizontal direction (i.e. epipolar lines are
  *  horizontal). This operation is useful for mainly two reasons: it
- *  allows to search for disparities in one direction only, and it
- *  allows to derives anaglyph for 3D viewing with 3D glasses.
+ *  allows searching for disparities in one direction only, and it
+ *  allows deriving anaglyph for 3D viewing with 3D glasses.
  *
  *  This filter allows you to compute the deformation fields up to the
  *  sensor model precision needed to warp a pair of stereo images into
@@ -66,13 +66,13 @@
  *  hypothesis on which the epipolar geometry is built. It means that
  *  any pair of pixels in the stereo pair whose elevation is exactly
  *  equal to the average elevation will have a null disparity (no
- *  displacement). The SetElevationOffset() method allows to tune the
+ *  displacement). The SetElevationOffset() method allows tuning the
  *  elevation offset which is only used for local epipolar lines
  *  estimation. The default value of 50 meters should do.
  *
- *  Additionnaly, the SetScale() method allows to derive deformation
+ *  Additionnaly, the SetScale() method allows deriving deformation
  *  fields and images size at a coarser (scale > 1) or finer (scale <
- *  1) resolution. The SetGridStep() allows to tune the step of the
+ *  1) resolution. The SetGridStep() allows tuning the step of the
  *  resampling grid. Please keep in mind that the whole grid is loaded
  *  into memory, and that the epipolar lines direction may only vary
  *  smoothly. When working with large images, a coarse grid-step will
--- otb.orig/Modules/Segmentation/OGRProcessing/include/otbOGRLayerStreamStitchingFilter.h
+++ otb/Modules/Segmentation/OGRProcessing/include/otbOGRLayerStreamStitchingFilter.h
@@ -39,7 +39,7 @@
  *  - P1 and P2 are on different side of the streaming line
  *  - P1 and P2 intersect each other.
  *  - P2 has the largest intersection with P1 among all other polygons Pi intersecting P1.
- *  The \c SetStreamSize() method allows to retrieve the number of streams in row and column,
+ *  The \c SetStreamSize() method allows retrieving the number of streams in row and column,
  *  and their pixel coordinates.
  *  The input image is used to transform pixel coordinates of the streaming lines into
  *  coordinate system of the image, which must be the same as the one in the OGR input file.
--- otb.orig/Modules/Segmentation/Watersheds/include/otbWatershedSegmentationFilter.h
+++ otb/Modules/Segmentation/Watersheds/include/otbWatershedSegmentationFilter.h
@@ -29,7 +29,7 @@
 *   \brief Watershed composite filter allowing to set output type
 *
 *   This filter is a composite filter that encapsulates the
-*   itk::WatershedImageFilter and allows to set the type of the output
+*   itk::WatershedImageFilter and allows setting the type of the output
 *   image (which is not the case in the itk::WatershedImageFilter).
 *
 *   The composite filter internally casts the output from the
--- otb.orig/Modules/Wrappers/ApplicationEngine/src/otbWrapperElevationParametersHandler.cxx
+++ otb/Modules/Wrappers/ApplicationEngine/src/otbWrapperElevationParametersHandler.cxx
@@ -28,14 +28,14 @@
 {
   app->AddParameter(ParameterType_Group, key, "Elevation management");
   app->SetParameterDescription(key,
-                               "This group of parameters allows to manage elevation values. Supported formats are SRTM, DTED or any geotiff. DownloadSRTMTiles application could be a useful tool to list/download tiles related to a product.");
+                               "This group of parameters allows managing elevation values. Supported formats are SRTM, DTED or any geotiff. DownloadSRTMTiles application could be a useful tool to list/download tiles related to a product.");
 
   // DEM directory
   std::ostringstream oss;
   oss << key<<".dem";
   app->AddParameter(ParameterType_Directory, oss.str(), "DEM directory");
   app->SetParameterDescription(oss.str(),
-                               "This parameter allows to select a directory containing Digital Elevation Model tiles");
+                               "This parameter allows selecting a directory containing Digital Elevation Model tiles");
   app->MandatoryOff(oss.str());
 
   std::string demDirFromConfig = otb::ConfigurationManager::GetDEMDirectory();
@@ -73,7 +73,7 @@
   oss.str("");
   oss << key <<".default";
   app->AddParameter(ParameterType_Float, oss.str(), "Default elevation");
-  app->SetParameterDescription(oss.str(),"This parameter allows to set the default height above ellipsoid when there is no DEM available, no coverage for some points or pixels with no_data in the DEM tiles, and no geoid file has been set. This is also used by some application as an average elevation value.");
+  app->SetParameterDescription(oss.str(),"This parameter allows setting the default height above ellipsoid when there is no DEM available, no coverage for some points or pixels with no_data in the DEM tiles, and no geoid file has been set. This is also used by some application as an average elevation value.");
   app->SetDefaultParameterFloat(oss.str(), 0.);
 
  // TODO : not implemented yet
--- otb.orig/Modules/Wrappers/ApplicationEngine/src/otbWrapperMapProjectionParametersHandler.cxx
+++ otb/Modules/Wrappers/ApplicationEngine/src/otbWrapperMapProjectionParametersHandler.cxx
@@ -41,7 +41,7 @@
 
   oss << ".zone";
   app->AddParameter(ParameterType_Int, oss.str(), "Zone number");
-  app->SetParameterDescription(oss.str(),"The zone number ranges from 1 to 60 and allows to define the transverse mercator projection (along with the hemisphere)");
+  app->SetParameterDescription(oss.str(),"The zone number ranges from 1 to 60 and allows defining the transverse mercator projection (along with the hemisphere)");
   app->SetMinimumParameterIntValue(oss.str(), 1);
   app->SetDefaultParameterInt(oss.str(), 31);
 
@@ -99,7 +99,7 @@
   oss<<key<<".epsg";
   app->AddChoice(oss.str(),"EPSG Code");
   app->SetParameterDescription(oss.str(),
-                               "This code is a generic way of identifying map projections, and allows to specify a large amount of them. See www.spatialreference.org to find which EPSG code is associated to your projection;");
+                               "This code is a generic way of identifying map projections, and allows specifying a large amount of them. See www.spatialreference.org to find which EPSG code is associated to your projection;");
 
   oss <<".code";
   app->AddParameter(ParameterType_Int, oss.str(), "EPSG Code");
--- otb.orig/RELEASE_NOTES.txt
+++ otb/RELEASE_NOTES.txt
@@ -118,7 +118,7 @@
 
   * Superbuild
     * A separate superbuild project has been added in the Superbuild repository
-    * It allows to build all OTB dependencies from source, and then OTB (thus replaces the removed internal versions)
+    * It allows building all OTB dependencies from source, and then OTB (thus replaces the removed internal versions)
     * Sources are checked out at configuration time or can be downloaded beforehand
     * Allow to build a complete OTB with a handful of prerequisites (gcc, cmake, curl)
   
@@ -169,7 +169,7 @@
     * 0001037: file and vector outputs need explicit relative paths
     * 0001036: TileFusion application crashes with SPOT-7 tiled images
     * 0000728: Inconsistent polygon number in concatenate vector data output
-    * 0001031: Wrong projection for ouput vector of segmentation application
+    * 0001031: Wrong projection for output vector of segmentation application
 
 
 OTB-v.4.4.0 - Changes since version 4.2.1 (2015/02/13)
@@ -481,13 +481,13 @@
     * 0000770: Output parameter does not appear anymore in the command line helper
     * 0000798: All the OTB app parameters are not all saved into the xml output file
     * 0000779: [OTB]otbTrainImagesClassifier generates an output *.CSV confusion matrix with a wrong header
-    * 0000809: LSMS Vectorization application didn't support ouput file with "-" special character
+    * 0000809: LSMS Vectorization application didn't support output file with "-" special character
     * 0000807: otbKmzExport application generate weird kmz if the tilesize parameter is equal to zero
     * 0000808: otbDownloadSRTMTiles application seems to be broken
     * 0000803: otbApplicationLauncherCommandLine -inxml parameter does not retrieve pixel type for output image parameter
     * 0000794: Tiling mechanism didn't work into Large Scale MeanShift  application
     * 0000760: ClassificationMapRegularization output pixel values are always on 8 bits
-    * 0000809: LSMS Vectorization application didn't support ouput file with "-" special character
+    * 0000809: LSMS Vectorization application didn't support output file with "-" special character
     * 0000803: otbApplicationLauncherCommandLine -inxml parameter does not retrieve pixel type for output image parameter
     * 0000736: Error setting the index in RadiometricIndices application via python
     * 0000800: Watershed mode of segmentation application produce an image without CRS even if the input image has one
@@ -570,7 +570,7 @@
       * DisparityMapTo3DFilter : convert disparity map in epipolar geometry to 3D image in epipolar geometry
       * MultiDisparityMapTo3DFilter : convert several disparity maps in sensor geometry to a 3D image in sensor geometry
       * LineOfSightOptimizer : algorithm to fuse several elevation values by line of sight optimisation
-      * BijectionCoherencyFilter : from 2 disparity maps, compute coherency left-right and right-left, and ouput a mask of coherent disparities
+      * BijectionCoherencyFilter : from 2 disparity maps, compute coherency left-right and right-left, and output a mask of coherent disparities
       * Multi3DToDEMFilter : fuse several 3D images to produce an elevation map
       * DisparityTranslateFilter : filter to translate epipolar disparities into sensor disparities
     * PixelWiseBlockMatchingImageFilter : fix initialisation of metric and disparities
@@ -998,7 +998,7 @@
     * Add image origin to ReadImageInfoApplication
     * Use now InputFilenameParameter and OutputFilenameParameter instead
       of FilenameParameter
-    * Use InputFilename and OuputFilename instead of Filename
+    * Use InputFilename and OutputFilename instead of Filename
     * New option in SVMClassifier application: sample.edg (non mandatory)
       to manage special cases with small samples
     * In KMeansClassification, Changing the random intialisation method
@@ -2017,7 +2017,7 @@
 OTB-v.2.4.0 - Changes since version 2.2.0 (2008/07/24)
 --------------------------------------------------------
 
-    - Added OTB_DISABLE_CXX_EXAMPLES_TESTING : allows to generate or
+    - Added OTB_DISABLE_CXX_EXAMPLES_TESTING : allows generating or
       not only examples testing
     - Added OTB_USE_JPEG2000 : experimental support for jpeg2000
       files.
@@ -2354,7 +2354,7 @@
 
     - Added a new tiling streaming mode.
 
-    - Added the otb::ImageGeometryHandler, which allows to handle
+    - Added the otb::ImageGeometryHandler, which allows handling
       seamlessly
       the image geometry information.
 
@@ -2438,16 +2438,16 @@
 
 *Applications:
 
-    - Added the otbImageViewerManager application which allows to
-      open multiple images,
+    - Added the otbImageViewerManager application which allows
+      opening multiple images,
       configure viewers and link displays.
 
     - Added the otbRoadExtraction which demonstrates the road
       extraction algorithm
       implemented in the FeatureExtraction module.
 
-    - Added the otbOrthoRectifAppli application which allows to
-      ortho rectify images in
+    - Added the otbOrthoRectifAppli application which allows
+      ortho rectifying images in
       command line using the brand new Projections module of the Orfeo
       ToolBox. Old rigid
       orthoo rectification application has been moved to
--- otb.orig/Utilities/Doxygen/OTB/ImageSimilarityMetrics.dox
+++ otb/Utilities/Doxygen/OTB/ImageSimilarityMetrics.dox
@@ -37,7 +37,7 @@
 Metrics are depend on the objects they compare. The toolkit currently offers <em> Image To Image </em> and <em> PointSet to Image </em> metrics as follows:
 
 \li <b> Mean Squares </b> Sum of squared differences between intensity values. It requires the two objects to have intensity values in the same range.
-\li <b> Normalized Correlation </b> Correlation between intensity values divided by the square rooted autocorrelation of both target and reference objects: \f$ \frac{\sum_i^n{a_i * b_i }}{\sum_i^n{a_i^2}\sum_i^n{b_i^2}} \f$. This metric allows to register objects whose intensity values are related by a linear transformation.
+\li <b> Normalized Correlation </b> Correlation between intensity values divided by the square rooted autocorrelation of both target and reference objects: \f$ \frac{\sum_i^n{a_i * b_i }}{\sum_i^n{a_i^2}\sum_i^n{b_i^2}} \f$. This metric allows registering objects whose intensity values are related by a linear transformation.
 \li <b> Pattern Intensity </b> Squared differences between intensity values transformed by a function of type  \f$ \frac{1}{1+x} \f$  and summed them up. This metric has the advantage of increase simultaneously when more samples are available and when intensity values are close.
 \li <b> Mutual Information </b> Mutual information is based in an information theory concept. Mutual information between two sets measures how much can be known from one set if only the other set is known. Given a set of values \f$ A=\{a_i\} \f$. Its entropy \f$ H(A) \f$  is defined by \f$ H(A) = \sum_i^n{- p(a_i) \log({p(a_i)})} \f$ where \f$ p(a_i) \f$ are the probabilities of the values in the set.  Entropy can be interpreted as a measure of the mean uncertainty reduction that is obtained when one of the particular values is found during sampling. Given two sets \f$ A=\{a_i\} \f$ and \f$ B=\{b_i\} \f$ its joint entropy is given by the joint probabilities \f$ p_(a_i,b_i) \f$ as \f$ H(A,B) = \sum_i^n{-p(a_i,b_i) * log( p(a_i, b_i) )} \f$. Mutual information is obtained by subtracting the entropy of both sets from the joint entropy, as : \f$ H(A,B)-H(A)-H(B) \f$, and indicates how much uncertainty about one set is reduced by the knowledge of the second set. Mutual information is the metric of choice when image from different modalities need to be registered.
 
--- otb.orig/Utilities/Doxygen/OTB/Registration.dox
+++ otb/Utilities/Doxygen/OTB/Registration.dox
@@ -75,7 +75,7 @@
 Metrics are depend on the objects they compare. The toolkit currently offers <em> Image To Image </em> and <em> PointSet to Image </em> metrics as follows:
 
 \li <b> Mean Squares </b> Sum of squared differences between intensity values. It requires the two objects to have intensity values in the same range.
-\li <b> Normalized Correlation </b> Correlation between intensity values divided by the square rooted autocorrelation of both target and reference objects: \f$ \frac{\sum_i^n{a_i * b_i }}{\sum_i^n{a_i^2}\sum_i^n{b_i^2}} \f$. This metric allows to register objects whose intensity values are related by a linear transformation.
+\li <b> Normalized Correlation </b> Correlation between intensity values divided by the square rooted autocorrelation of both target and reference objects: \f$ \frac{\sum_i^n{a_i * b_i }}{\sum_i^n{a_i^2}\sum_i^n{b_i^2}} \f$. This metric allows registering objects whose intensity values are related by a linear transformation.
 \li <b> Pattern Intensity </b> Squared differences between intensity values transformed by a function of type  \f$ \frac{1}{1+x} \f$  and summed them up. This metric has the advantage of increase simultaneously when more samples are available and when intensity values are close.
 \li <b> Mutual Information </b> Mutual information is based in an information theory concept. Mutual information between two sets measures how much can be known from one set if only the other set is known. Given a set of values \f$ A=\{a_i\} \f$. Its entropy \f$ H(A) \f$  is defined by \f$ H(A) = \sum_i^n{- p(a_i) \log({p(a_i)})} \f$ where \f$ p(a_i) \f$ are the probabilities of the values in the set.  Entropy can be interpreted as a measure of the mean uncertainty reduction that is obtained when one of the particular values is found during sampling. Given two sets \f$ A=\{a_i\} \f$ and \f$ B=\{b_i\} \f$ its joint entropy is given by the joint probabilities \f$ p_(a_i,b_i) \f$ as \f$ H(A,B) = \sum_i^n{-p(a_i,b_i) * log( p(a_i, b_i) )} \f$. Mutual information is obtained by subtracting the entropy of both sets from the joint entropy, as : \f$ H(A,B)-H(A)-H(B) \f$, and indicates how much uncertainty about one set is reduced by the knowledge of the second set. Mutual information is the metric of choice when image from different modalities need to be registered.
 
--- otb.orig/Examples/Projections/GeometriesProjectionExample.cxx
+++ otb/Examples/Projections/GeometriesProjectionExample.cxx
@@ -140,7 +140,7 @@
   // not stored in a file nor a data base.
   //
   // Then, the processing is started by calling \code{Update()}. The actual
-  // serialization of the results is guaranteed to be completed when the ouput
+  // serialization of the results is guaranteed to be completed when the output
   // geometries set object goes out of scope, or when \code{SyncToDisk} is
   // called.
   //
--- otb.orig/Modules/Adapters/OSSIMAdapters/src/otbDEMConvertAdapter.cxx
+++ otb/Modules/Adapters/OSSIMAdapters/src/otbDEMConvertAdapter.cxx
@@ -140,7 +140,7 @@
       {
       std::cerr << "std::exception  thrown:" << std::endl;
       std::cerr << e.what() <<  std::endl;
-      itkExceptionMacro("Error occurs writing the ouput image...");
+      itkExceptionMacro("Error occurs writing the output image...");
       return EXIT_FAILURE;
       }
     }
--- otb.orig/Modules/Filtering/Projection/test/otbGenericRSResampleImageFilter.cxx
+++ otb/Modules/Filtering/Projection/test/otbGenericRSResampleImageFilter.cxx
@@ -81,7 +81,7 @@
   spacing[0] = 0.6;
   spacing[1] = -0.6;
 
-  // Build the ouput projection ref : UTM ref
+  // Build the output projection ref : UTM ref
   OGRSpatialReference    oSRS;
   oSRS.SetProjCS("UTM");
   oSRS.SetUTM(31, true);
--- otb.orig/Modules/IO/IOGDAL/test/otbMultiDatasetReadingInfo.cxx
+++ otb/Modules/IO/IOGDAL/test/otbMultiDatasetReadingInfo.cxx
@@ -27,7 +27,7 @@
 {
   if (argc != 3)
     {
-    std::cout << argv[0] << "<image HDF> <ouput filename>" << std::endl;
+    std::cout << argv[0] << "<image HDF> <output filename>" << std::endl;
     return EXIT_FAILURE;
     }
   const char * inputFilename  = argv[1];
--- otb.orig/Modules/IO/ImageIO/test/otbMultiResolutionReadingInfo.cxx
+++ otb/Modules/IO/ImageIO/test/otbMultiResolutionReadingInfo.cxx
@@ -29,7 +29,7 @@
 {
   if (argc != 3)
     {
-    std::cout << argv[0] << "<input filename> <ouput filename>" << std::endl;
+    std::cout << argv[0] << "<input filename> <output filename>" << std::endl;
     return EXIT_FAILURE;
     }
   const char * inputFilename  = argv[1];
--- otb.orig/Modules/Registration/DisparityMap/test/otbDisparityMapToDEMFilter.cxx
+++ otb/Modules/Registration/DisparityMap/test/otbDisparityMapToDEMFilter.cxx
@@ -61,7 +61,7 @@
     std::cerr
         << " dispinput_fname sensorleftinput_fname sensorrighttinput_fname gridleftinput_fname gridrightinput_fname"
         << std::endl;
-    std::cerr << " ouputDEM_filename " << std::endl;
+    std::cerr << " outputDEM_filename " << std::endl;
     std::cerr << " elevmin elevmax avgelev DEMgridstep (maskinput_fname) " << std::endl;
     return EXIT_FAILURE;
     }
--- otb.orig/Modules/Segmentation/MorphologicalProfiles/include/otbMorphologicalProfilesSegmentationFilter.h
+++ otb/Modules/Segmentation/MorphologicalProfiles/include/otbMorphologicalProfilesSegmentationFilter.h
@@ -54,14 +54,14 @@
  *
  * \ingroup OTBMorphologicalProfiles
 */
-template <class TInputImage,  class TOuputImage, class TInternalPrecision = float, class TStructuringElement = itk::BinaryBallStructuringElement<typename TInputImage::PixelType, TInputImage::ImageDimension> >
+template <class TInputImage,  class TOutputImage, class TInternalPrecision = float, class TStructuringElement = itk::BinaryBallStructuringElement<typename TInputImage::PixelType, TInputImage::ImageDimension> >
 class ITK_EXPORT MorphologicalProfilesSegmentationFilter
-  : public itk::ImageToImageFilter<TInputImage, TOuputImage>
+  : public itk::ImageToImageFilter<TInputImage, TOutputImage>
 {
 public:
 /** Standard Self typedef */
 typedef MorphologicalProfilesSegmentationFilter Self;
-typedef itk::ImageToImageFilter<TInputImage, TOuputImage> Superclass;
+typedef itk::ImageToImageFilter<TInputImage, TOutputImage> Superclass;
 
 typedef itk::SmartPointer<Self>       Pointer;
 typedef itk::SmartPointer<const Self> ConstPointer;
@@ -69,7 +69,7 @@
 /** Some convenient typedefs. */
 typedef TInputImage                        InputImageType;
 typedef typename InputImageType::PixelType InputPixelType;
-typedef TOuputImage                        OutputImageType;
+typedef TOutputImage                       OutputImageType;
 typedef otb::Image<TInternalPrecision>     InternalImageType;
 
 typedef TStructuringElement                StructuringElementType;
--- otb.orig/Modules/Segmentation/MorphologicalProfiles/include/otbMorphologicalProfilesSegmentationFilter.txx
+++ otb/Modules/Segmentation/MorphologicalProfiles/include/otbMorphologicalProfilesSegmentationFilter.txx
@@ -23,8 +23,8 @@
 namespace otb
 {
 
-template <class TInputImage,  class TOuputImage, class TInternalPrecision, class TStructuringElement>
-MorphologicalProfilesSegmentationFilter<TInputImage,TOuputImage,TInternalPrecision,TStructuringElement>
+template <class TInputImage,  class TOutputImage, class TInternalPrecision, class TStructuringElement>
+MorphologicalProfilesSegmentationFilter<TInputImage,TOutputImage,TInternalPrecision,TStructuringElement>
 ::MorphologicalProfilesSegmentationFilter()
 {
   m_ProfileSize = 5;
@@ -54,14 +54,14 @@
 
 }
 
-template <class TInputImage,  class TOuputImage, class TInternalPrecision, class TStructuringElement>
-MorphologicalProfilesSegmentationFilter<TInputImage,TOuputImage,TInternalPrecision,TStructuringElement>
+template <class TInputImage,  class TOutputImage, class TInternalPrecision, class TStructuringElement>
+MorphologicalProfilesSegmentationFilter<TInputImage,TOutputImage,TInternalPrecision,TStructuringElement>
 ::~MorphologicalProfilesSegmentationFilter()
 {}
 
-template <class TInputImage,  class TOuputImage, class TInternalPrecision, class TStructuringElement>
+template <class TInputImage,  class TOutputImage, class TInternalPrecision, class TStructuringElement>
 void
-MorphologicalProfilesSegmentationFilter<TInputImage,TOuputImage,TInternalPrecision,TStructuringElement>
+MorphologicalProfilesSegmentationFilter<TInputImage,TOutputImage,TInternalPrecision,TStructuringElement>
 ::GenerateData()
 {
   m_OpeningProfile->SetInput(this->GetInput());
--- otb.orig/Modules/Wrappers/CommandLine/src/CMakeLists.txt
+++ otb/Modules/Wrappers/CommandLine/src/CMakeLists.txt
@@ -16,7 +16,7 @@
 otb_module_target(otbApplicationLauncherCommandLine)
 
 # Where we will install the script in the build tree
-get_target_property(CLI_OUPUT_DIR otbApplicationLauncherCommandLine RUNTIME_OUTPUT_DIRECTORY)
+get_target_property(CLI_OUTPUT_DIR otbApplicationLauncherCommandLine RUNTIME_OUTPUT_DIRECTORY)
 
 # Generate a script in the build dir, next to the cli launcher
 # Need a two-step process since configure_file don't support permissions
@@ -27,11 +27,11 @@
                 ${CMAKE_BINARY_DIR}${CMAKE_FILES_DIRECTORY}/Scripts/otbcli.bat
                 @ONLY )
 file(COPY ${CMAKE_BINARY_DIR}${CMAKE_FILES_DIRECTORY}/Scripts/otbcli.bat
-     DESTINATION ${CLI_OUPUT_DIR}
+     DESTINATION ${CLI_OUTPUT_DIR}
      FILE_PERMISSIONS OWNER_READ OWNER_WRITE OWNER_EXECUTE GROUP_READ GROUP_EXECUTE WORLD_READ WORLD_EXECUTE)
 
 # TODO : test if NO_INSTALL is set
-install(PROGRAMS ${CLI_OUPUT_DIR}/otbcli.bat
+install(PROGRAMS ${CLI_OUTPUT_DIR}/otbcli.bat
         DESTINATION ${OTBCommandLine_INSTALL_RUNTIME_DIR}
         COMPONENT Runtime)
 
@@ -40,11 +40,11 @@
                 ${CMAKE_BINARY_DIR}${CMAKE_FILES_DIRECTORY}/Scripts/otbcli
                 @ONLY )
 file(COPY ${CMAKE_BINARY_DIR}${CMAKE_FILES_DIRECTORY}/Scripts/otbcli
-     DESTINATION ${CLI_OUPUT_DIR}
+     DESTINATION ${CLI_OUTPUT_DIR}
      FILE_PERMISSIONS OWNER_READ OWNER_WRITE OWNER_EXECUTE GROUP_READ GROUP_EXECUTE WORLD_READ WORLD_EXECUTE)
 
 # TODO : test if NO_INSTALL is set
-install(PROGRAMS ${CLI_OUPUT_DIR}/otbcli
+install(PROGRAMS ${CLI_OUTPUT_DIR}/otbcli
         DESTINATION ${OTBCommandLine_INSTALL_RUNTIME_DIR}
         COMPONENT Runtime)
 
--- otb.orig/Modules/Wrappers/QtWidget/src/CMakeLists.txt
+++ otb/Modules/Wrappers/QtWidget/src/CMakeLists.txt
@@ -91,7 +91,7 @@
 otb_module_target(otbApplicationLauncherQt)
 
 # Where we will install the script in the build tree
-get_target_property(GUI_OUPUT_DIR otbApplicationLauncherQt RUNTIME_OUTPUT_DIRECTORY)
+get_target_property(GUI_OUTPUT_DIR otbApplicationLauncherQt RUNTIME_OUTPUT_DIRECTORY)
 
 # Generate a script in the build dir, next to the gui launcher
 # Need a two-step process since configure_file don't support permissions
@@ -103,11 +103,11 @@
                 ${CMAKE_BINARY_DIR}${CMAKE_FILES_DIRECTORY}/Scripts/otbgui.bat
                 @ONLY )
 file(COPY ${CMAKE_BINARY_DIR}${CMAKE_FILES_DIRECTORY}/Scripts/otbgui.bat
-     DESTINATION ${GUI_OUPUT_DIR}
+     DESTINATION ${GUI_OUTPUT_DIR}
      FILE_PERMISSIONS OWNER_READ OWNER_WRITE OWNER_EXECUTE GROUP_READ GROUP_EXECUTE WORLD_READ WORLD_EXECUTE)
 
 # TODO : test if NO_INSTALL is set
-install(PROGRAMS ${GUI_OUPUT_DIR}/otbgui.bat
+install(PROGRAMS ${GUI_OUTPUT_DIR}/otbgui.bat
         DESTINATION ${OTBQtWidget_INSTALL_RUNTIME_DIR}
         COMPONENT Runtime)
 
@@ -116,11 +116,11 @@
                 ${CMAKE_BINARY_DIR}${CMAKE_FILES_DIRECTORY}/Scripts/otbgui
                 @ONLY )
 file(COPY ${CMAKE_BINARY_DIR}${CMAKE_FILES_DIRECTORY}/Scripts/otbgui
-     DESTINATION ${GUI_OUPUT_DIR}
+     DESTINATION ${GUI_OUTPUT_DIR}
      FILE_PERMISSIONS OWNER_READ OWNER_WRITE OWNER_EXECUTE GROUP_READ GROUP_EXECUTE WORLD_READ WORLD_EXECUTE)
 
 # TODO : test if NO_INSTALL is set
-install(PROGRAMS ${GUI_OUPUT_DIR}/otbgui
+install(PROGRAMS ${GUI_OUTPUT_DIR}/otbgui
         DESTINATION ${OTBQtWidget_INSTALL_RUNTIME_DIR}
         COMPONENT Runtime)
 
--- otb.orig/Modules/Detection/RoadExtraction/include/otbRemoveWrongDirectionFilter.h
+++ otb/Modules/Detection/RoadExtraction/include/otbRemoveWrongDirectionFilter.h
@@ -63,7 +63,7 @@
  *  we can assume that the direction of a road on our scalar product image is positive (greater
  *  than \f$ \pi/8 \f$).
  *  Therefore in the input modulus and direction images, pixels whose direction is lower than
- *  this threshold are supressed
+ *  this threshold are suppressed
  *  (in fact, their intensity is set to 0).
  *
  * \sa NeighborhoodScalarProductFilter
--- otb.orig/Modules/Feature/Edge/include/otbPixelSuppressionByDirectionImageFilter.h
+++ otb/Modules/Feature/Edge/include/otbPixelSuppressionByDirectionImageFilter.h
@@ -31,7 +31,7 @@
  *
  * This class implements an image filter which detects isolated pixels
  * that have little chance of belonging to a raod and performs a pixel
- * supression. For each pixel kept with direction \f$ \theta_{i} \f$, we look
+ * suppression. For each pixel kept with direction \f$ \theta_{i} \f$, we look
  * for other pixels with a direction close to \f$ \theta_i \f$ in an angular
  * beam around it. If none is found, the pixel is suppressed.
  *
--- otb.orig/Modules/Filtering/ImageManipulation/include/otbSpectralAngleDistanceImageFilter.txx
+++ otb/Modules/Filtering/ImageManipulation/include/otbSpectralAngleDistanceImageFilter.txx
@@ -107,7 +107,7 @@
       {
       dist = vcl_acos(scalarProd / vcl_sqrt(normProd));
       }
-    //------ This part was supressed since the filter must perform only the spectral angle computation ---
+    //------ This part was suppressed since the filter must perform only the spectral angle computation ---
     // Spectral angle normalization
     // dist = dist/(CONST_PI_2);
     //square ponderation
--- otb.orig/Modules/Learning/DempsterShafer/include/otbDSFusionOfClassifiersImageFilter.txx
+++ otb/Modules/Learning/DempsterShafer/include/otbDSFusionOfClassifiersImageFilter.txx
@@ -307,7 +307,7 @@
 
   // Calculation of the four constants A, B, C and K
   MassType A = 0, B = 1, C = 1, K;
-  K = 0; //supress warning. not sure about default value ??
+  K = 0; //suppress warning. not sure about default value ??
   for (itMapMOBClk = mapJointMassesStepI.begin(); itMapMOBClk != mapJointMassesStepI.end(); ++itMapMOBClk)
     {
     classLabelk = itMapMOBClk->first;
--- otb.orig/Modules/Wrappers/ApplicationEngine/src/otbWrapperDocExampleStructure.cxx
+++ otb/Modules/Wrappers/ApplicationEngine/src/otbWrapperDocExampleStructure.cxx
@@ -145,7 +145,7 @@
 
   res = oss.str();
 
-  // Supress last added space
+  // Suppress last added space
   res.erase( res.size()-1, 1);
 
   return res.c_str();
--- otb.orig/Modules/Wrappers/CommandLine/src/otbWrapperCommandLineParser.cxx
+++ otb/Modules/Wrappers/CommandLine/src/otbWrapperCommandLineParser.cxx
@@ -496,7 +496,7 @@
 
   while( found != std::string::npos )
     {
-    // Supress everything before the key
+    // Suppress everything before the key
     cutExp = cutExp.substr(found+2, exp.size());
     // Search the end of the key (a space)
     std::size_t foundSpace = cutExp.find(" ");
--- otb.orig/Modules/Wrappers/QtWidget/include/otbWrapperQtWidgetInputFilenameListParameter.h
+++ otb/Modules/Wrappers/QtWidget/include/otbWrapperQtWidgetInputFilenameListParameter.h
@@ -51,7 +51,7 @@
   virtual void UpFile();
   virtual void DownFile();
   virtual void AddFile();
-  virtual void SupressFile();
+  virtual void SuppressFile();
   virtual void EraseFile();
   virtual void UpdateFilenameList();
 
--- otb.orig/Modules/Wrappers/QtWidget/include/otbWrapperQtWidgetInputImageListParameter.h
+++ otb/Modules/Wrappers/QtWidget/include/otbWrapperQtWidgetInputImageListParameter.h
@@ -51,7 +51,7 @@
   virtual void UpFile();
   virtual void DownFile();
   virtual void AddFile();
-  virtual void SupressFile();
+  virtual void SuppressFile();
   virtual void EraseFile();
   virtual void UpdateImageList();
 
--- otb.orig/Modules/Wrappers/QtWidget/include/otbWrapperQtWidgetInputVectorDataListParameter.h
+++ otb/Modules/Wrappers/QtWidget/include/otbWrapperQtWidgetInputVectorDataListParameter.h
@@ -52,7 +52,7 @@
   virtual void UpFile();
   virtual void DownFile();
   virtual void AddFile();
-  virtual void SupressFile();
+  virtual void SuppressFile();
   virtual void EraseFile();
   virtual void UpdateVectorDataList();
 
--- otb.orig/Modules/Wrappers/QtWidget/include/otbWrapperQtWidgetStringListParameter.h
+++ otb/Modules/Wrappers/QtWidget/include/otbWrapperQtWidgetStringListParameter.h
@@ -46,7 +46,7 @@
 protected slots:
   void SetString( const QString& value );
   virtual void AddString();
-  virtual void SupressString();
+  virtual void SuppressString();
   virtual void UpdateStringList();
 
 private:
--- otb.orig/Modules/Wrappers/QtWidget/src/otbWrapperQtWidgetInputFilenameListParameter.cxx
+++ otb/Modules/Wrappers/QtWidget/src/otbWrapperQtWidgetInputFilenameListParameter.cxx
@@ -87,12 +87,12 @@
   connect(addButton, SIGNAL(clicked()), this, SLOT(AddFile()));
   addSupLayout->addWidget(addButton);
 
-  // Supress file button
+  // Suppress file button
   QPushButton * supButton = new QPushButton;
   supButton->setText("-");
   supButton->setFixedWidth(buttonSize);
-  supButton->setToolTip("Supress the selected file...");
-  connect(supButton, SIGNAL(clicked()), this, SLOT(SupressFile()));
+  supButton->setToolTip("Suppress the selected file...");
+  connect(supButton, SIGNAL(clicked()), this, SLOT(SuppressFile()));
   addSupLayout->addWidget(supButton);
   buttonLayout->addLayout(addSupLayout);
 
@@ -312,7 +312,7 @@
 }
 
 void
-QtWidgetInputFilenameListParameter::SupressFile()
+QtWidgetInputFilenameListParameter::SuppressFile()
 {
   m_FileLayout = new QVBoxLayout();
   m_FileLayout->setSpacing(0);
--- otb.orig/Modules/Wrappers/QtWidget/src/otbWrapperQtWidgetInputImageListParameter.cxx
+++ otb/Modules/Wrappers/QtWidget/src/otbWrapperQtWidgetInputImageListParameter.cxx
@@ -89,12 +89,12 @@
   connect(addButton, SIGNAL(clicked()), this, SLOT(AddFile()));
   addSupLayout->addWidget(addButton);
 
-  // Supress file button
+  // Suppress file button
   QPushButton * supButton = new QPushButton;
   supButton->setText("-");
   supButton->setFixedWidth(buttonSize);
-  supButton->setToolTip("Supress the selected file...");
-  connect(supButton, SIGNAL(clicked()), this, SLOT(SupressFile()));
+  supButton->setToolTip("Suppress the selected file...");
+  connect(supButton, SIGNAL(clicked()), this, SLOT(SuppressFile()));
   addSupLayout->addWidget(supButton);
   buttonLayout->addLayout(addSupLayout);
 
@@ -332,7 +332,7 @@
 }
 
 void
-QtWidgetInputImageListParameter::SupressFile()
+QtWidgetInputImageListParameter::SuppressFile()
 {
   m_FileLayout = new QVBoxLayout();
   m_FileLayout->setSpacing(0);
--- otb.orig/Modules/Wrappers/QtWidget/src/otbWrapperQtWidgetInputVectorDataListParameter.cxx
+++ otb/Modules/Wrappers/QtWidget/src/otbWrapperQtWidgetInputVectorDataListParameter.cxx
@@ -86,12 +86,12 @@
   connect(addButton, SIGNAL(clicked()), this, SLOT(AddFile()));
   addSupLayout->addWidget(addButton);
 
-  // Supress file button
+  // Suppress file button
   QPushButton * supButton = new QPushButton;
   supButton->setText("-");
   supButton->setFixedWidth(buttonSize);
-  supButton->setToolTip("Supress the selected file...");
-  connect(supButton, SIGNAL(clicked()), this, SLOT(SupressFile()));
+  supButton->setToolTip("Suppress the selected file...");
+  connect(supButton, SIGNAL(clicked()), this, SLOT(SuppressFile()));
   addSupLayout->addWidget(supButton);
   buttonLayout->addLayout(addSupLayout);
 
@@ -311,7 +311,7 @@
 }
 
 void
-QtWidgetInputVectorDataListParameter::SupressFile()
+QtWidgetInputVectorDataListParameter::SuppressFile()
 {
   m_FileLayout = new QVBoxLayout();
   m_FileLayout->setSpacing(0);
--- otb.orig/Modules/Wrappers/QtWidget/src/otbWrapperQtWidgetStringListParameter.cxx
+++ otb/Modules/Wrappers/QtWidget/src/otbWrapperQtWidgetStringListParameter.cxx
@@ -88,12 +88,12 @@
     connect( addButton, SIGNAL(clicked()), this, SLOT(AddString()) );
     addSupLayout->addWidget(addButton);
 
-    // Supress file button
+    // Suppress file button
     QPushButton * supButton = new QPushButton;
     supButton->setText("-");
     supButton->setFixedWidth(buttonSize);
-    supButton->setToolTip("Supress the selected string...");
-    connect( supButton, SIGNAL(clicked()), this, SLOT(SupressString()) );
+    supButton->setToolTip("Suppress the selected string...");
+    connect( supButton, SIGNAL(clicked()), this, SLOT(SuppressString()) );
     addSupLayout->addWidget(supButton);
     buttonLayout->addLayout(addSupLayout);
 
@@ -177,7 +177,7 @@
 
 
 void
-QtWidgetStringListParameter::SupressString()
+QtWidgetStringListParameter::SuppressString()
 {
   m_StringLayout = new QVBoxLayout();
   m_StringLayout->setSpacing(0);
--- otb.orig/Modules/Applications/AppClassification/app/otbTrainRegression.cxx
+++ otb/Modules/Applications/AppClassification/app/otbTrainRegression.cxx
@@ -122,7 +122,7 @@
 
   //Group IO
   AddParameter(ParameterType_Group, "io", "Input and output data");
-  SetParameterDescription("io", "This group of parameters allows to set input and output data.");
+  SetParameterDescription("io", "This group of parameters allows setting input and output data.");
   AddParameter(ParameterType_InputImageList, "io.il", "Input Image List");
   SetParameterDescription("io.il", "A list of input images. First (n-1) bands should contain the predictor. The last band should contain the output value to predict.");
   AddParameter(ParameterType_InputFilename, "io.csv", "Input CSV file");
@@ -144,7 +144,7 @@
   //Group Sample list
   AddParameter(ParameterType_Group, "sample", "Training and validation samples parameters");
   SetParameterDescription("sample",
-                          "This group of parameters allows to set training and validation sample lists parameters.");
+                          "This group of parameters allows setting training and validation sample lists parameters.");
 
   AddParameter(ParameterType_Int, "sample.mt", "Maximum training predictors");
   //MandatoryOff("mt");
@@ -230,7 +230,7 @@
           }
         if (words.size() < 2)
           {
-          otbAppLogFATAL(<< "Can't parse CSV file : less than 2 columns or unknonw separator (knowns ones are tab, space, comma and semi-colon)");
+          otbAppLogFATAL(<< "Can't parse CSV file : less than 2 columns or unknown separator (knowns ones are tab, space, comma and semi-colon)");
           }
         nbCols = words.size();
         elem.SetSize(nbCols,false);
--- otb.orig/Modules/Applications/AppClassification/app/otbPredictRegression.cxx
+++ otb/Modules/Applications/AppClassification/app/otbPredictRegression.cxx
@@ -141,7 +141,7 @@
     // TODO : use CSV input/output ?
 
     AddParameter(ParameterType_InputImage,  "mask",   "Input Mask");
-    SetParameterDescription( "mask", "The mask allows to restrict "
+    SetParameterDescription( "mask", "The mask allow restricting "
       "classification of the input image to the area where mask pixel values "
       "are greater than 0.");
     MandatoryOff("mask");
--- otb.orig/Modules/Applications/AppClassification/app/otbTrainImagesClassifier.cxx
+++ otb/Modules/Applications/AppClassification/app/otbTrainImagesClassifier.cxx
@@ -115,7 +115,7 @@
     "Samples are composed of pixel values in each band optionally centered and reduced using an XML statistics file produced by "
     "the ComputeImagesStatistics application.\n The training vector data must contain polygons with a positive integer field "
     "representing the class label. The name of this field can be set using the \"Class label field\" parameter. Training and validation "
-    "sample lists are built such that each class is equally represented in both lists. One parameter allows to control the ratio "
+    "sample lists are built such that each class is equally represented in both lists. One parameter allows controlling the ratio "
     "between the number of samples in training and validation sets. Two parameters allow to manage the size of the training and "
     "validation sets per class and per image.\n Several classifier parameters can be set depending on the chosen classifier. In the "
     "validation process, the confusion matrix is organized the following way: rows = reference labels, columns = produced labels. "
@@ -128,7 +128,7 @@
 
   //Group IO
   AddParameter(ParameterType_Group, "io", "Input and output data");
-  SetParameterDescription("io", "This group of parameters allows to set input and output data.");
+  SetParameterDescription("io", "This group of parameters allows setting input and output data.");
   AddParameter(ParameterType_InputImageList, "io.il", "Input Image List");
   SetParameterDescription("io.il", "A list of input images.");
   AddParameter(ParameterType_InputVectorDataList, "io.vd", "Input Vector Data List");
@@ -149,7 +149,7 @@
   //Group Sample list
   AddParameter(ParameterType_Group, "sample", "Training and validation samples parameters");
   SetParameterDescription("sample",
-                          "This group of parameters allows to set training and validation sample lists parameters.");
+                          "This group of parameters allows setting training and validation sample lists parameters.");
 
   AddParameter(ParameterType_Int, "sample.mt", "Maximum training sample size per class");
   //MandatoryOff("mt");
--- otb.orig/Modules/Applications/AppImageUtils/app/otbManageNoData.cxx
+++ otb/Modules/Applications/AppImageUtils/app/otbManageNoData.cxx
@@ -61,7 +61,7 @@
     SetDescription("Manage No-Data");
     // Documentation
     SetDocName("No Data management");
-    SetDocLongDescription("This application has two modes. The first allows to build a mask of no-data pixels from the no-data flags read from the image file. The second allows to update the change the no-data value of an image (pixels value and metadata). This last mode also allows to replace NaN in images with a proper no-data value. To do so, one should activate the NaN is no-data option.");
+    SetDocLongDescription("This application has two modes. The first allows building a mask of no-data pixels from the no-data flags read from the image file. The second allows updating the change the no-data value of an image (pixels value and metadata). This last mode also allows replacing NaN in images with a proper no-data value. To do so, one should activate the NaN is no-data option.");
     SetDocLimitations("None");
     SetDocAuthors("OTB-Team");
     SetDocSeeAlso("BanMath");
--- otb.orig/Modules/Applications/AppSARCalibration/app/otbSarRadiometricCalibration.cxx
+++ otb/Modules/Applications/AppSARCalibration/app/otbSarRadiometricCalibration.cxx
@@ -49,7 +49,7 @@
 
     // Documentation
     SetDocName("SAR Radiometric calibration");
-    SetDocLongDescription("The objective of SAR calibration is to provide imagery in which the pixel values can be directly related to the radar backscatter of the scene. This application allows to compute Sigma Naught (Radiometric Calibration) for TerraSAR-X, Sentinel1 L1 and Radarsat-2 sensors. Metadata are automatically retrieved from image products.The application supports complex and non-complex images (SLC or detected products).\n");
+    SetDocLongDescription("The objective of SAR calibration is to provide imagery in which the pixel values can be directly related to the radar backscatter of the scene. This application allows one to compute Sigma Naught (Radiometric Calibration) for TerraSAR-X, Sentinel1 L1 and Radarsat-2 sensors. Metadata are automatically retrieved from image products.The application supports complex and non-complex images (SLC or detected products).\n");
     SetDocLimitations("None");
     SetDocAuthors("OTB-Team");
     SetDocSeeAlso(" ");
--- otb.orig/Modules/Applications/AppSARDecompositions/app/otbSARDecompositions.cxx
+++ otb/Modules/Applications/AppSARDecompositions/app/otbSARDecompositions.cxx
@@ -111,7 +111,7 @@
     SetParameterDescription("decomp.haa","H-alpha-A decomposition");
     
     AddParameter(ParameterType_Group,"inco","Incoherent decompositions");
-    SetParameterDescription("inco","This group allows to set parameters related to the incoherent decompositions.");
+    SetParameterDescription("inco","This group allows setting parameters related to the incoherent decompositions.");
     
     AddParameter(ParameterType_Int, "inco.kernelsize",   "Kernel size for spatial incoherent averaging.");
     SetParameterDescription("inco.kernelsize", "Minute (0-59)");
--- otb.orig/Modules/Wrappers/SWIG/src/numpy.i
+++ otb/Modules/Wrappers/SWIG/src/numpy.i
@@ -123,7 +123,7 @@
     if (PyInstance_Check(py_obj)) return "instance"    ;
 %#endif
 
-    return "unkown type";
+    return "unknown type";
   }
 
   /* Given a NumPy typecode, return a string describing the type.
