Author: Andreas Tille <tille@debian.org>
Last-Update: Thu, 10 Jul 2014 10:07:30 +0200
Description: Fix some spelling errors to silence lintian enabling
 to concentrate on the real problem.
 .
 Feel free to take over this s/allows to/allows one to/.

--- otb.orig/Applications/Classification/otbTrainImagesClassifier.cxx
+++ otb/Applications/Classification/otbTrainImagesClassifier.cxx
@@ -35,7 +35,7 @@
     "Samples are composed of pixel values in each band optionally centered and reduced using an XML statistics file produced by "
     "the ComputeImagesStatistics application.\n The training vector data must contain polygons with a positive integer field "
     "representing the class label. The name of this field can be set using the \"Class label field\" parameter. Training and validation "
-    "sample lists are built such that each class is equally represented in both lists. One parameter allows to control the ratio "
+    "sample lists are built such that each class is equally represented in both lists. One parameter allows one to control the ratio "
     "between the number of samples in training and validation sets. Two parameters allow to manage the size of the training and "
     "validation sets per class and per image.\n Several classifier parameters can be set depending on the chosen classifier. In the "
     "validation process, the confusion matrix is organized the following way: rows = reference labels, columns = produced labels. "
@@ -50,7 +50,7 @@
 
   //Group IO
   AddParameter(ParameterType_Group, "io", "Input and output data");
-  SetParameterDescription("io", "This group of parameters allows to set input and output data.");
+  SetParameterDescription("io", "This group of parameters allows one to set input and output data.");
   AddParameter(ParameterType_InputImageList, "io.il", "Input Image List");
   SetParameterDescription("io.il", "A list of input images.");
   AddParameter(ParameterType_InputVectorDataList, "io.vd", "Input Vector Data List");
@@ -71,7 +71,7 @@
   //Group Sample list
   AddParameter(ParameterType_Group, "sample", "Training and validation samples parameters");
   SetParameterDescription("sample",
-                          "This group of parameters allows to set training and validation sample lists parameters.");
+                          "This group of parameters allows one to set training and validation sample lists parameters.");
 
   AddParameter(ParameterType_Int, "sample.mt", "Maximum training sample size per class");
   //MandatoryOff("mt");
--- otb.orig/Applications/Classification/otbTrainKNN.cxx
+++ otb/Applications/Classification/otbTrainKNN.cxx
@@ -25,7 +25,7 @@
   void TrainImagesClassifier::InitKNNParams()
   {
     AddChoice("classifier.knn", "KNN classifier");
-    SetParameterDescription("classifier.knn", "This group of parameters allows to set KNN classifier parameters. "
+    SetParameterDescription("classifier.knn", "This group of parameters allows one to set KNN classifier parameters. "
         "See complete documentation here \\url{http://docs.opencv.org/modules/ml/doc/k_nearest_neighbors.html}.");
 
     //K parameter
--- otb.orig/Applications/Classification/otbTrainNeuralNetwork.cxx
+++ otb/Applications/Classification/otbTrainNeuralNetwork.cxx
@@ -26,7 +26,7 @@
 {
   AddChoice("classifier.ann", "Artificial Neural Network classifier");
   SetParameterDescription("classifier.ann",
-                          "This group of parameters allows to set Artificial Neural Network classifier parameters. "
+                          "This group of parameters allows one to set Artificial Neural Network classifier parameters. "
                           "See complete documentation here \\url{http://docs.opencv.org/modules/ml/doc/neural_networks.html}.");
 
   //TrainMethod
--- otb.orig/Applications/Classification/otbTrainBoost.cxx
+++ otb/Applications/Classification/otbTrainBoost.cxx
@@ -25,7 +25,7 @@
   void TrainImagesClassifier::InitBoostParams()
   {
     AddChoice("classifier.boost", "Boost classifier");
-    SetParameterDescription("classifier.boost", "This group of parameters allows to set Boost classifier parameters. "
+    SetParameterDescription("classifier.boost", "This group of parameters allows one to set Boost classifier parameters. "
         "See complete documentation here \\url{http://docs.opencv.org/modules/ml/doc/boosting.html}.");
     //BoostType
     AddParameter(ParameterType_Choice, "classifier.boost.t", "Boost Type");
--- otb.orig/Applications/Classification/otbTrainSVM.cxx
+++ otb/Applications/Classification/otbTrainSVM.cxx
@@ -25,7 +25,7 @@
   void TrainImagesClassifier::InitSVMParams()
   {
     AddChoice("classifier.svm", "SVM classifier (OpenCV)");
-    SetParameterDescription("classifier.svm", "This group of parameters allows to set SVM classifier parameters. "
+    SetParameterDescription("classifier.svm", "This group of parameters allows one to set SVM classifier parameters. "
         "See complete documentation here \\url{http://docs.opencv.org/modules/ml/doc/support_vector_machines.html}.");
     AddParameter(ParameterType_Choice, "classifier.svm.m", "SVM Model Type");
     AddChoice("classifier.svm.m.csvc", "C support vector classification");
--- otb.orig/Applications/Classification/otbClassificationMapRegularization.cxx
+++ otb/Applications/Classification/otbClassificationMapRegularization.cxx
@@ -71,7 +71,7 @@
 
     /** GROUP IO CLASSIFICATION */
     AddParameter(ParameterType_Group,"io","Input and output images");
-    SetParameterDescription("io","This group of parameters allows to set input and output images for classification map regularization by Majority Voting.");
+    SetParameterDescription("io","This group of parameters allows one to set input and output images for classification map regularization by Majority Voting.");
 
     AddParameter(ParameterType_InputImage, "io.in",  "Input classification image");
     SetParameterDescription( "io.in", "The input labeled image to regularize.");
@@ -82,7 +82,7 @@
 
 
     AddParameter(ParameterType_Group,"ip","Regularization parameters");
-    SetParameterDescription("ip","This group allows to set parameters for classification map regularization by Majority Voting.");
+    SetParameterDescription("ip","This group allows one to set parameters for classification map regularization by Majority Voting.");
 
     AddParameter(ParameterType_Int, "ip.radius", "Structuring element radius (in pixels)");
     SetParameterDescription("ip.radius", "The radius of the ball shaped structuring element (expressed in pixels). By default, 'ip.radius = 1 pixel'.");
--- otb.orig/Applications/Classification/otbFusionOfClassifications.cxx
+++ otb/Applications/Classification/otbFusionOfClassifications.cxx
@@ -97,7 +97,7 @@
     SetName("FusionOfClassifications");
     SetDescription("Fuses several classifications maps of the same image on the basis of class labels.");
     SetDocName("Fusion of Classifications");
-    SetDocLongDescription("This application allows to fuse several classification maps and produces a single more robust classification map. "
+    SetDocLongDescription("This application allows one to fuse several classification maps and produces a single more robust classification map. "
         "Fusion is done either by mean of Majority Voting, or with the Dempster Shafer combination method on class labels.\n "
         "-MAJORITY VOTING: for each pixel, the class with the highest number of votes is selected.\n "
         "-DEMPSTER SHAFER: for each pixel, the class label for which the Belief Function is maximal is selected. This Belief Function is calculated "
--- otb.orig/Applications/Classification/otbTrainDecisionTree.cxx
+++ otb/Applications/Classification/otbTrainDecisionTree.cxx
@@ -25,7 +25,7 @@
 {
   AddChoice("classifier.dt", "Decision Tree classifier");
   SetParameterDescription("classifier.dt",
-                          "This group of parameters allows to set Decision Tree classifier parameters. "
+                          "This group of parameters allows one to set Decision Tree classifier parameters. "
                           "See complete documentation here \\url{http://docs.opencv.org/modules/ml/doc/decision_trees.html}.");
   //MaxDepth
   AddParameter(ParameterType_Int, "classifier.dt.max", "Maximum depth of the tree");
--- otb.orig/Applications/Classification/otbTrainGradientBoostedTree.cxx
+++ otb/Applications/Classification/otbTrainGradientBoostedTree.cxx
@@ -26,7 +26,7 @@
   AddChoice("classifier.gbt", "Gradient Boosted Tree classifier");
   SetParameterDescription(
       "classifier.gbt",
-      "This group of parameters allows to set Gradient Boosted Tree classifier parameters. "
+      "This group of parameters allows one to set Gradient Boosted Tree classifier parameters. "
       "See complete documentation here \\url{http://docs.opencv.org/modules/ml/doc/gradient_boosted_trees.html}.");
   //LossFunctionType : not exposed, as only one type is used for Classification,
   // the other three are used for regression.
--- otb.orig/Applications/Rasterization/otbRasterization.cxx
+++ otb/Applications/Rasterization/otbRasterization.cxx
@@ -64,7 +64,7 @@
     SetDescription("Rasterize a vector dataset.");
 
     SetDocName("Rasterization");
-    SetDocLongDescription("This application allows to reproject and rasterize a vector dataset. The grid of the rasterized output can be set by using a reference image, or by setting all parmeters (origin, size, spacing) by hand. In the latter case, at least the spacing (ground sampling distance) is needed (other parameters are computed automatically). The rasterized output can also be in a different projection reference system than the input dataset.\n There are two rasterize mode available in the application. The first is the binary mode: it allows to render all pixels belonging to a geometry of the input dataset in the foreground color, while rendering the other in background color. The second one allows to render pixels belonging to a geometry woth respect to an attribute of this geometry. The field of the attribute to render can be set by the user. In the second mode, the background value is still used for unassociated pixels.");
+    SetDocLongDescription("This application allows one to reproject and rasterize a vector dataset. The grid of the rasterized output can be set by using a reference image, or by setting all parmeters (origin, size, spacing) by hand. In the latter case, at least the spacing (ground sampling distance) is needed (other parameters are computed automatically). The rasterized output can also be in a different projection reference system than the input dataset.\n There are two rasterize mode available in the application. The first is the binary mode: it allows one to render all pixels belonging to a geometry of the input dataset in the foreground color, while rendering the other in background color. The second one allows one to render pixels belonging to a geometry woth respect to an attribute of this geometry. The field of the attribute to render can be set by the user. In the second mode, the background value is still used for unassociated pixels.");
     SetDocLimitations("None");
     SetDocAuthors("OTB-Team");
     SetDocSeeAlso("For now, support of input dataset with multiple layers having different projection reference system is limited.");
--- otb.orig/Applications/Classification/otbImageClassifier.cxx
+++ otb/Applications/Classification/otbImageClassifier.cxx
@@ -81,7 +81,7 @@
     SetParameterDescription( "in", "The input image to classify.");
 
     AddParameter(ParameterType_InputImage,  "mask",   "Input Mask");
-    SetParameterDescription( "mask", "The mask allows to restrict classification of the input image to the area where mask pixel values are greater than 0.");
+    SetParameterDescription( "mask", "The mask allows one to restrict classification of the input image to the area where mask pixel values are greater than 0.");
     MandatoryOff("mask");
 
     AddParameter(ParameterType_InputFilename, "model", "Model file");
--- otb.orig/Applications/Classification/otbTrainLibSVM.cxx
+++ otb/Applications/Classification/otbTrainLibSVM.cxx
@@ -25,7 +25,7 @@
   void TrainImagesClassifier::InitLibSVMParams()
   {
     AddChoice("classifier.libsvm", "LibSVM classifier");
-    SetParameterDescription("classifier.libsvm", "This group of parameters allows to set SVM classifier parameters.");
+    SetParameterDescription("classifier.libsvm", "This group of parameters allows one to set SVM classifier parameters.");
     AddParameter(ParameterType_Choice, "classifier.libsvm.k", "SVM Kernel Type");
     AddChoice("classifier.libsvm.k.linear", "Linear");
     AddChoice("classifier.libsvm.k.rbf", "Gaussian radial basis function");
--- otb.orig/Applications/Classification/otbTrainRandomForests.cxx
+++ otb/Applications/Classification/otbTrainRandomForests.cxx
@@ -25,7 +25,7 @@
 {
   AddChoice("classifier.rf", "Random forests classifier");
   SetParameterDescription("classifier.rf",
-                          "This group of parameters allows to set Random Forests classifier parameters. "
+                          "This group of parameters allows one to set Random Forests classifier parameters. "
                           "See complete documentation here \\url{http://docs.opencv.org/modules/ml/doc/random_trees.html}.");
   //MaxDepth
   AddParameter(ParameterType_Int, "classifier.rf.max", "Maximum depth of the tree");
--- otb.orig/Applications/DisparityMap/otbBlockMatching.cxx
+++ otb/Applications/DisparityMap/otbBlockMatching.cxx
@@ -128,11 +128,11 @@
     SetDescription("Performs block-matching to estimate pixel-wise disparities between two images");
 
     SetDocName("Pixel-wise Block-Matching");
-    SetDocLongDescription("This application allows to performs block-matching to estimate pixel-wise disparities "
-      "between two images. The application allows to choose the block-matching method to use. It also allows to input"
+    SetDocLongDescription("This application allows one to performs block-matching to estimate pixel-wise disparities "
+      "between two images. The application allows one to choose the block-matching method to use. It also allows one to input"
       " masks (related to the left and right input image) of pixels for which the disparity should be investigated. "
       "Additionally, two criteria can be optionally used to disable disparity investigation for some pixel: a "
-      "no-data value, and a threshold on the local variance. This allows to speed-up computation by avoiding to "
+      "no-data value, and a threshold on the local variance. This allows one to speed-up computation by avoiding to "
       "investigate disparities that will not be reliable anyway. For efficiency reasons, if the optimal metric values"
       " image is desired, it will be concatenated to the output image (which will then have three bands : horizontal "
       "disparity, vertical disparity and metric value). One can split these images afterward.");
@@ -143,7 +143,7 @@
     AddDocTag(Tags::Stereo);
 
     AddParameter(ParameterType_Group,"io","Input and output data");
-    SetParameterDescription("io","This group of parameters allows to set the input and output images.");
+    SetParameterDescription("io","This group of parameters allows one to set the input and output images.");
 
     AddParameter(ParameterType_InputImage,"io.inleft","Left input image");
     SetParameterDescription("io.inleft","The left input image (reference)");
@@ -163,24 +163,24 @@
     SetParameterDescription("io.outmetric","If used, the output image will have a second component with metric optimal values");
 
     AddParameter(ParameterType_Group,"mask","Image masking parameters");
-    SetParameterDescription("mask","This group of parameters allows to determine the masking parameters to prevent disparities estimation for some pixels of the left image");
+    SetParameterDescription("mask","This group of parameters allows one to determine the masking parameters to prevent disparities estimation for some pixels of the left image");
 
     AddParameter(ParameterType_InputImage,"mask.inleft","Discard left pixels from mask image");
-    SetParameterDescription("mask.inleft","This parameter allows to provide a custom mask for the left image.Block matching will be only perform on pixels inside the mask.");
+    SetParameterDescription("mask.inleft","This parameter allows one to provide a custom mask for the left image.Block matching will be only perform on pixels inside the mask.");
     MandatoryOff("mask.inleft");
 
     AddParameter(ParameterType_InputImage,"mask.inright","Discard right pixels from mask image");
-    SetParameterDescription("mask.inright","This parameter allows to provide a custom mask for the right image.Block matching will be perform only on pixels inside the mask.");
+    SetParameterDescription("mask.inright","This parameter allows one to provide a custom mask for the right image.Block matching will be perform only on pixels inside the mask.");
     MandatoryOff("mask.inright");
 
     AddParameter(ParameterType_Float,"mask.nodata","Discard pixels with no-data value");
-    SetParameterDescription("mask.nodata","This parameter allows to discard pixels whose value is equal to the user-defined no-data value.");
+    SetParameterDescription("mask.nodata","This parameter allows one to discard pixels whose value is equal to the user-defined no-data value.");
     MandatoryOff("mask.nodata");
     SetDefaultParameterFloat("mask.nodata",0.);
     DisableParameter("mask.nodata");
 
     AddParameter(ParameterType_Float,"mask.variancet","Discard pixels with low local variance");
-    SetParameterDescription("mask.variancet","This parameter allows to discard pixels whose local variance is too small (the size of the neighborhood is given by the radius parameter)");
+    SetParameterDescription("mask.variancet","This parameter allows one to discard pixels whose local variance is too small (the size of the neighborhood is given by the radius parameter)");
     MandatoryOff("mask.variancet");
     SetDefaultParameterFloat("mask.variancet",100.);
     DisableParameter("mask.variancet");
--- otb.orig/Applications/DisparityMap/otbDisparityMapToElevationMap.cxx
+++ otb/Applications/DisparityMap/otbDisparityMapToElevationMap.cxx
@@ -77,7 +77,7 @@
     AddDocTag(Tags::Stereo);
 
     AddParameter(ParameterType_Group,"io","Input and output data");
-    SetParameterDescription("io","This group of parameters allows to set the input and output images and grids.");
+    SetParameterDescription("io","This group of parameters allows one to set the input and output images and grids.");
 
     AddParameter(ParameterType_InputImage,"io.in","Input disparity map");
     SetParameterDescription("io.in","The input disparity map (horizontal disparity in first band, vertical in second)");
--- otb.orig/Applications/DisparityMap/otbStereoFramework.cxx
+++ otb/Applications/DisparityMap/otbStereoFramework.cxx
@@ -340,7 +340,7 @@
 
     // Add the output paramters in a group
     AddParameter(ParameterType_Group, "input", "Input parameters");
-    SetParameterDescription("input","This group of parameters allows to parametrize input data.");
+    SetParameterDescription("input","This group of parameters allows one to parametrize input data.");
 
     AddParameter(ParameterType_InputImageList,  "input.il",   "Input images list");
     SetParameterDescription("input.il", "The list of images.");
@@ -361,7 +361,7 @@
 
     // Add the output paramters in a group
     AddParameter(ParameterType_Group, "output", "Output parameters");
-    SetParameterDescription("output","This group of parameters allows to choose the DSM resolution, nodata value, and projection parameters.");
+    SetParameterDescription("output","This group of parameters allows one to choose the DSM resolution, nodata value, and projection parameters.");
 
     // // Build the Output Map Projection
     // for custom map projection
@@ -379,7 +379,7 @@
 
     // UserDefined values
     AddParameter(ParameterType_Choice, "output.fusionmethod", "Method to fuse measures in each DSM cell");
-    SetParameterDescription("output.fusionmethod","This parameter allows to choose the method used to fuse elevation measurements in each output DSM cell");
+    SetParameterDescription("output.fusionmethod","This parameter allows one to choose the method used to fuse elevation measurements in each output DSM cell");
     AddChoice("output.fusionmethod.max", "The cell is filled with the maximum measured elevation values");
     AddChoice("output.fusionmethod.min", "The cell is filled with the minimum measured elevation values");
     AddChoice("output.fusionmethod.mean","The cell is filled with the mean of measured elevation values");
@@ -418,7 +418,7 @@
 
     // Add the output paramters in a group
     AddParameter(ParameterType_Group, "stereorect", "Stereorectification Grid parameters");
-    SetParameterDescription("stereorect","This group of parameters allows to choose direct and inverse grid subsampling. These parameters are very useful to tune time and memory consumption.");
+    SetParameterDescription("stereorect","This group of parameters allows one to choose direct and inverse grid subsampling. These parameters are very useful to tune time and memory consumption.");
 
     AddParameter(ParameterType_Int,"stereorect.fwdgridstep","Step of the displacement grid (in pixels)");
     SetParameterDescription("stereorect.fwdgridstep","Stereo-rectification displacement grid only varies slowly. Therefore, it is recommended to use a coarser grid (higher step value) in case of large images");
@@ -426,7 +426,7 @@
     MandatoryOff("stereorect.fwdgridstep");
 
     AddParameter(ParameterType_Int, "stereorect.invgridssrate", "Sub-sampling rate for epipolar grid inversion");
-    SetParameterDescription("stereorect.invgridssrate","Grid inversion is an heavy process that implies spline regression on control points. To avoid eating to much memory, this parameter allows to first sub-sample the field to invert.");
+    SetParameterDescription("stereorect.invgridssrate","Grid inversion is an heavy process that implies spline regression on control points. To avoid eating to much memory, this parameter allows one to first sub-sample the field to invert.");
     SetDefaultParameterInt("stereorect.invgridssrate",10);
     SetMinimumParameterIntValue("stereorect.invgridssrate",1);
     MandatoryOff("stereorect.invgridssrate");
@@ -505,7 +505,7 @@
     DisableParameter("mask.right");
 
     AddParameter(ParameterType_Float,"mask.variancet","Discard pixels with low local variance");
-    SetParameterDescription("mask.variancet","This parameter allows to discard pixels whose local variance is too small (the size of the neighborhood is given by the radius parameter)");
+    SetParameterDescription("mask.variancet","This parameter allows one to discard pixels whose local variance is too small (the size of the neighborhood is given by the radius parameter)");
     MandatoryOff("mask.variancet");
     SetDefaultParameterFloat("mask.variancet",50.);
     //DisableParameter("mask.variancet");
--- otb.orig/Applications/Hyperspectral/otbHyperspectralUnmixing.cxx
+++ otb/Applications/Hyperspectral/otbHyperspectralUnmixing.cxx
@@ -100,7 +100,7 @@
 
     // Documentation
     SetDocName("Hyperspectral data unmixing");
-    SetDocLongDescription("The application applies a linear unmixing algorithm to an hyperspectral data cube. This method supposes that the mixture between materials in the scene is macroscopic and simulates a linear mixing model of spectra.\nThe Linear Mixing Model (LMM) acknowledges that reflectance spectrum associated with each pixel is a linear combination of pure materials in the recovery area, commonly known as endmembers. Endmembers can be estimated using the VertexComponentAnalysis application.\nThe application allows to estimate the abundance maps with several algorithms : Unconstrained Least Square (ucls), Fully Constrained Least Square (fcls), Image Space Reconstruction Algorithm (isra) and Non-negative constrained Least Square (ncls) and Minimum Dispertion Constrained Non Negative Matrix Factorization (MDMDNMF).\n");
+    SetDocLongDescription("The application applies a linear unmixing algorithm to an hyperspectral data cube. This method supposes that the mixture between materials in the scene is macroscopic and simulates a linear mixing model of spectra.\nThe Linear Mixing Model (LMM) acknowledges that reflectance spectrum associated with each pixel is a linear combination of pure materials in the recovery area, commonly known as endmembers. Endmembers can be estimated using the VertexComponentAnalysis application.\nThe application allows one to estimate the abundance maps with several algorithms : Unconstrained Least Square (ucls), Fully Constrained Least Square (fcls), Image Space Reconstruction Algorithm (isra) and Non-negative constrained Least Square (ncls) and Minimum Dispertion Constrained Non Negative Matrix Factorization (MDMDNMF).\n");
     SetDocLimitations("None");
     SetDocAuthors("OTB-Team");
     SetDocSeeAlso("VertexComponentAnalysis");
--- otb.orig/Applications/FeatureExtraction/otbLineSegmentDetection.cxx
+++ otb/Applications/FeatureExtraction/otbLineSegmentDetection.cxx
@@ -59,7 +59,7 @@
 
     // Documentation
     SetDocName("Line segment detection");
-    SetDocLongDescription("This application detects locally straight contours in a image. It is based on Burns, Hanson, and Riseman method and use an a contrario validation approach (Desolneux, Moisan, and Morel). The algorithm was published by Rafael Gromponevon Gioi, Jérémie Jakubowicz, Jean-Michel Morel and Gregory Randall.\n The given approach computes gradient and level lines of the image and detects aligned points in line support region. The application allows to export the detected lines in a vector data.");
+    SetDocLongDescription("This application detects locally straight contours in a image. It is based on Burns, Hanson, and Riseman method and use an a contrario validation approach (Desolneux, Moisan, and Morel). The algorithm was published by Rafael Gromponevon Gioi, Jérémie Jakubowicz, Jean-Michel Morel and Gregory Randall.\n The given approach computes gradient and level lines of the image and detects aligned points in line support region. The application allows one to export the detected lines in a vector data.");
     SetDocLimitations("None");
     SetDocAuthors("OTB-Team");
     SetDocSeeAlso("On Line demonstration of the LSD algorithm is available here: http://www.ipol.im/pub/algo/gjmr_line_segment_detector/\n");
--- otb.orig/Applications/FeatureExtraction/otbSFSTextureExtraction.cxx
+++ otb/Applications/FeatureExtraction/otbSFSTextureExtraction.cxx
@@ -81,7 +81,7 @@
 AddRAMParameter();
 
 AddParameter(ParameterType_Group, "parameters", "Texture feature parameters");
-SetParameterDescription("parameters","This group of parameters allows to define SFS texture parameters.\
+SetParameterDescription("parameters","This group of parameters allows one to define SFS texture parameters.\
     The available texture features are SFS'Length, SFS'Width, SFS'PSI, SFS'W-Mean, SFS'Ratio and SFS'SD.\
     They are provided in this exact order in the output image.");
 
--- otb.orig/Applications/Utils/otbColorMapping.cxx
+++ otb/Applications/Utils/otbColorMapping.cxx
@@ -257,10 +257,10 @@
     SetDescription("Maps an input label image to 8-bits RGB using look-up tables.");
 
     SetDocName("Color Mapping");
-    SetDocLongDescription("This application allows to map a label image to a 8-bits RGB image (in both ways) using different methods.\n"
-                          " -The custom method allows to use a custom look-up table. The look-up table is loaded "
+    SetDocLongDescription("This application allows one to map a label image to a 8-bits RGB image (in both ways) using different methods.\n"
+                          " -The custom method allows one to use a custom look-up table. The look-up table is loaded "
                           "from a text file where each line describes an entry. The typical use of this method is to colorise a "
-                          "classification map.\n -The continuous method allows to map a range of values in a scalar input image "
+                          "classification map.\n -The continuous method allows one to map a range of values in a scalar input image "
                           "to a colored image using continuous look-up table, in order to enhance image interpretation. Several "
                           "look-up tables can been chosen with different color ranges.\n-The optimal method computes an optimal "
                           "look-up table. When processing a segmentation label image (label to color), the color difference between"
--- otb.orig/Applications/Utils/otbMultiResolutionPyramid.cxx
+++ otb/Applications/Utils/otbMultiResolutionPyramid.cxx
@@ -97,7 +97,7 @@
     // Boolean Fast scheme
     AddParameter(ParameterType_Empty, "fast", "Use Fast Scheme");
     std::ostringstream desc;
-    desc<<"If used, this option allows to speed-up computation by iteratively"
+    desc<<"If used, this option allows one to speed-up computation by iteratively"
         <<" subsampling previous level of pyramid instead of processing the full input.";
     SetParameterDescription("fast", desc.str());
     MandatoryOff("fast");
--- otb.orig/Applications/ChangeDetection/otbMultivariateAlterationDetector.cxx
+++ otb/Applications/ChangeDetection/otbMultivariateAlterationDetector.cxx
@@ -75,7 +75,7 @@
                   " \n"
                   " The GetV1() and GetV2() methods allow to retrieve the linear "
                   " combinations used to generate the Mad change maps as a vnl_matrix of "
-                  " double, and the GetRho() method allows to retrieve the correlation "
+                  " double, and the GetRho() method allows one to retrieve the correlation "
                   " associated to each Mad change maps as a vnl_vector. \n"
                   " \n"
                   " This filter has been implemented from the Matlab code kindly made "
--- otb.orig/Applications/DisparityMap/otbStereoRectificationGridGenerator.cxx
+++ otb/Applications/DisparityMap/otbStereoRectificationGridGenerator.cxx
@@ -112,7 +112,7 @@
     SetDocSeeAlso("otbGridBasedImageResampling");
 
     AddParameter(ParameterType_Group,"io","Input and output data");
-    SetParameterDescription("io","This group of parameters allows to set the input and output images.");
+    SetParameterDescription("io","This group of parameters allows one to set the input and output images.");
     AddParameter(ParameterType_InputImage,"io.inleft","Left input image");
     SetParameterDescription("io.inleft","The left input image to resample");
 
@@ -156,7 +156,7 @@
     DisableParameter("epi.elevation.avgdem.maxdisp");
 
     AddParameter(ParameterType_Float,"epi.scale","Scale of epipolar images");
-    SetParameterDescription("epi.scale","The scale parameter allows to generated zoomed-in (scale < 1) or zoomed-out (scale > 1) epipolar images.");
+    SetParameterDescription("epi.scale","The scale parameter allows one to generated zoomed-in (scale < 1) or zoomed-out (scale > 1) epipolar images.");
     SetDefaultParameterFloat("epi.scale",1.);
 
     AddParameter(ParameterType_Int,"epi.step","Step of the deformation grid (in nb. of pixels)");
@@ -176,7 +176,7 @@
     SetParameterRole("epi.baseline", Role_Output);
 
     AddParameter(ParameterType_Group,"inverse","Write inverse fields");
-    SetParameterDescription("inverse","This group of parameter allows to generate the inverse fields as well");
+    SetParameterDescription("inverse","This group of parameter allows one to generate the inverse fields as well");
 
     AddParameter(ParameterType_OutputImage, "inverse.outleft", "Left inverse deformation grid");
     SetParameterDescription("inverse.outleft","The output deformation grid to be used to resample the epipolar left image");
@@ -187,7 +187,7 @@
     MandatoryOff("inverse.outright");
 
     AddParameter(ParameterType_Int, "inverse.ssrate", "Sub-sampling rate for inversion");
-    SetParameterDescription("inverse.ssrate","Grid inversion is an heavy process that implies spline regression on control points. To avoid eating to much memory, this parameter allows to first sub-sample the field to invert.");
+    SetParameterDescription("inverse.ssrate","Grid inversion is an heavy process that implies spline regression on control points. To avoid eating to much memory, this parameter allows one to first sub-sample the field to invert.");
     SetDefaultParameterInt("inverse.ssrate",16);
     SetMinimumParameterIntValue("inverse.ssrate",1);
 
--- otb.orig/Applications/FeatureExtraction/otbHaralickTextureExtraction.cxx
+++ otb/Applications/FeatureExtraction/otbHaralickTextureExtraction.cxx
@@ -92,7 +92,7 @@
 AddRAMParameter();
 
 AddParameter(ParameterType_Group, "parameters", "Texture feature parameters");
-SetParameterDescription("parameters","This group of parameters allows to define texture parameters.");
+SetParameterDescription("parameters","This group of parameters allows one to define texture parameters.");
 
 AddParameter(ParameterType_Int,"parameters.xrad","X Radius");
 SetParameterDescription("parameters.xrad", "X Radius");
--- otb.orig/Applications/FeatureExtraction/otbHomologousPointsExtraction.cxx
+++ otb/Applications/FeatureExtraction/otbHomologousPointsExtraction.cxx
@@ -85,18 +85,18 @@
     SetName("HomologousPointsExtraction");
     SetDocName("Homologous points extraction");
     SetDescription("Allows to compute homologous points between images using keypoints");
-    SetDocLongDescription("This application allows to compute homologous points between images using keypoints. "
+    SetDocLongDescription("This application allows one to compute homologous points between images using keypoints. "
       " SIFT or SURF keypoints can be used and the band on which keypoints are computed can be set independantly for both images."
       " The application offers two modes :"
       " the first is the full mode where keypoints are extracted from the full extent of both images"
       " (please note that in this mode large image file are not supported). "
-      "The second mode, called geobins, allows to set-up spatial binning to get fewer points"
+      "The second mode, called geobins, allows one to set-up spatial binning to get fewer points"
       " spread accross the entire image. "
       "In this mode, the corresponding spatial bin in the second image is estimated using geographical"
       " transform or sensor modelling, and is padded according to the user defined precision. Last, in"
       " both modes the application can filter matches whose colocalisation in first image exceed this precision. "
       "The elevation parameters are to deal more precisely with sensor modelling in case of sensor geometry data. "
-      "The outvector option allows to create a vector file with segments corresponding to the localisation error between the matches."
+      "The outvector option allows one to create a vector file with segments corresponding to the localisation error between the matches."
       " It can be useful to assess the precision of a registration for instance."
       " The vector file is always reprojected to EPSG:4326 to allow display in a GIS."
       " This is done via reprojection or by applying the image sensor models.");
@@ -146,7 +146,7 @@
     SetParameterDescription("mode.full","Extract and match all keypoints, loading both images entirely into memory");
 
     AddChoice("mode.geobins","Search keypoints in small spatial bins regularly spread accross first image");
-    SetParameterDescription("mode.geobins","This method allows to retrieve a set of tie points regulary spread accross image 1. Corresponding bins in image 2 are retrieved using sensor and geographical information if available.");
+    SetParameterDescription("mode.geobins","This method allows one to retrieve a set of tie points regulary spread accross image 1. Corresponding bins in image 2 are retrieved using sensor and geographical information if available.");
     AddParameter(ParameterType_Int,"mode.geobins.binsize","Size of bin");
     SetParameterDescription("mode.geobins.binsize","Radius of the spatial bin in pixels");
     SetDefaultParameterInt("mode.geobins.binsize",256);
@@ -162,7 +162,7 @@
     SetDefaultParameterFloat("precision",0.);
 
     AddParameter(ParameterType_Empty,"mfilter","Filter points according to geographical or sensor based colocalisation");
-    SetParameterDescription("mfilter","If enabled, this option allows to filter matches according to colocalisation from sensor or geographical information, using the given tolerancy expressed in pixels");
+    SetParameterDescription("mfilter","If enabled, this option allows one to filter matches according to colocalisation from sensor or geographical information, using the given tolerancy expressed in pixels");
 
     AddParameter(ParameterType_Empty,"2wgs84","If enabled, points from second image will be exported in WGS84");
 
--- otb.orig/Applications/Projections/otbGridBasedImageResampling.cxx
+++ otb/Applications/Projections/otbGridBasedImageResampling.cxx
@@ -107,7 +107,7 @@
     SetDescription("Resamples an image according to a resampling grid");
 
     SetDocName("Grid Based Image Resampling");
-    SetDocLongDescription("This application allows to perform image resampling from an input resampling grid.");
+    SetDocLongDescription("This application allows one to perform image resampling from an input resampling grid.");
     SetDocLimitations("None");
     SetDocAuthors("OTB-Team");
 
@@ -116,7 +116,7 @@
     SetDocSeeAlso("otbStereorecificationGridGeneration");
 
     AddParameter(ParameterType_Group,"io","Input and output data");
-    SetParameterDescription("io","This group of parameters allows to set the input and output images.");
+    SetParameterDescription("io","This group of parameters allows one to set the input and output images.");
     AddParameter(ParameterType_InputImage,"io.in","Input image");
     SetParameterDescription("io.in","The input image to resample");
     AddParameter(ParameterType_OutputImage, "io.out", "Output Image");
@@ -161,14 +161,14 @@
 
     // Interpolators
     AddParameter(ParameterType_Choice,   "interpolator", "Interpolation");
-    SetParameterDescription("interpolator","This group of parameters allows to define how the input image will be interpolated during resampling.");
+    SetParameterDescription("interpolator","This group of parameters allows one to define how the input image will be interpolated during resampling.");
     AddChoice("interpolator.nn",     "Nearest Neighbor interpolation");
     SetParameterDescription("interpolator.nn","Nearest neighbor interpolation leads to poor image quality, but it is very fast.");
     AddChoice("interpolator.linear", "Linear interpolation");
     SetParameterDescription("interpolator.linear","Linear interpolation leads to average image quality but is quite fast");
     AddChoice("interpolator.bco",    "Bicubic interpolation");
     AddParameter(ParameterType_Radius, "interpolator.bco.radius", "Radius for bicubic interpolation");
-    SetParameterDescription("interpolator.bco.radius","This parameter allows to control the size of the bicubic interpolation filter. If the target pixel size is higher than the input pixel size, increasing this parameter will reduce aliasing artefacts.");
+    SetParameterDescription("interpolator.bco.radius","This parameter allows one to control the size of the bicubic interpolation filter. If the target pixel size is higher than the input pixel size, increasing this parameter will reduce aliasing artefacts.");
     SetDefaultParameterInt("interpolator.bco.radius", 2);
     SetParameterString("interpolator","bco");
 
--- otb.orig/Applications/Projections/otbOrthoRectification.cxx
+++ otb/Applications/Projections/otbOrthoRectification.cxx
@@ -91,7 +91,7 @@
   {
     SetName("OrthoRectification");
     std::ostringstream oss;
-    oss << "This application allows to ortho-rectify optical images from supported sensors." << std::endl;
+    oss << "This application allows one to ortho-rectify optical images from supported sensors." << std::endl;
     SetDescription(oss.str());
     // Documentation
     SetDocName("Ortho-rectification");
@@ -109,7 +109,7 @@
 
     // Set the parameters
     AddParameter(ParameterType_Group,"io","Input and output data");
-    SetParameterDescription("io","This group of parameters allows to set the input and output images.");
+    SetParameterDescription("io","This group of parameters allows one to set the input and output images.");
     AddParameter(ParameterType_InputImage, "io.in", "Input Image");
     SetParameterDescription("io.in","The input image to ortho-rectify");
     AddParameter(ParameterType_OutputImage, "io.out", "Output Image");
@@ -120,7 +120,7 @@
 
     // Add the output paramters in a group
     AddParameter(ParameterType_Group, "outputs", "Output Image Grid");
-    SetParameterDescription("outputs","This group of parameters allows to define the grid on which the input image will be resampled.");
+    SetParameterDescription("outputs","This group of parameters allows one to define the grid on which the input image will be resampled.");
 
     // UserDefined values
     AddParameter(ParameterType_Choice, "outputs.mode", "Parameters estimation modes");
@@ -196,26 +196,26 @@
     AddParameter(ParameterType_Choice,   "interpolator", "Interpolation");
     AddChoice("interpolator.bco",    "Bicubic interpolation");
     AddParameter(ParameterType_Radius, "interpolator.bco.radius", "Radius for bicubic interpolation");
-    SetParameterDescription("interpolator.bco.radius","This parameter allows to control the size of the bicubic interpolation filter. If the target pixel size is higher than the input pixel size, increasing this parameter will reduce aliasing artefacts.");
-    SetParameterDescription("interpolator","This group of parameters allows to define how the input image will be interpolated during resampling.");
+    SetParameterDescription("interpolator.bco.radius","This parameter allows one to control the size of the bicubic interpolation filter. If the target pixel size is higher than the input pixel size, increasing this parameter will reduce aliasing artefacts.");
+    SetParameterDescription("interpolator","This group of parameters allows one to define how the input image will be interpolated during resampling.");
     AddChoice("interpolator.nn",     "Nearest Neighbor interpolation");
     SetParameterDescription("interpolator.nn","Nearest neighbor interpolation leads to poor image quality, but it is very fast.");
     AddChoice("interpolator.linear", "Linear interpolation");
     SetParameterDescription("interpolator.linear","Linear interpolation leads to average image quality but is quite fast");
     SetDefaultParameterInt("interpolator.bco.radius", 2);
     AddParameter(ParameterType_Group,"opt","Speed optimization parameters");
-    SetParameterDescription("opt","This group of parameters allows to optimize processing time.");
+    SetParameterDescription("opt","This group of parameters allows one to optimize processing time.");
 
     // Estimate a RPC model (for spot image for instance)
     AddParameter(ParameterType_Int, "opt.rpc", "RPC modeling (points per axis)");
     SetDefaultParameterInt("opt.rpc", 10);
-    SetParameterDescription("opt.rpc","Enabling RPC modeling allows to speed-up SPOT5 ortho-rectification. Value is the number of control points per axis for RPC estimation");
+    SetParameterDescription("opt.rpc","Enabling RPC modeling allows one to speed-up SPOT5 ortho-rectification. Value is the number of control points per axis for RPC estimation");
     DisableParameter("opt.rpc");
     MandatoryOff("opt.rpc");
 
     // RAM available
     AddRAMParameter("opt.ram");
-    SetParameterDescription("opt.ram","This allows to set the maximum amount of RAM available for processing. As the writing task is time consuming, it is better to write large pieces of data, which can be achieved by increasing this parameter (pay attention to your system capabilities)");
+    SetParameterDescription("opt.ram","This allows one to set the maximum amount of RAM available for processing. As the writing task is time consuming, it is better to write large pieces of data, which can be achieved by increasing this parameter (pay attention to your system capabilities)");
 
     // Displacement Field Spacing
     AddParameter(ParameterType_Float, "opt.gridspacing", "Resampling grid spacing");
--- otb.orig/Applications/Projections/otbRefineSensorModel.cxx
+++ otb/Applications/Projections/otbRefineSensorModel.cxx
@@ -60,7 +60,7 @@
     SetDescription("Perform least-square fit of a sensor model to a set of tie points");
 
     SetDocName("Refine Sensor Model");
-    SetDocLongDescription("This application reads a geom file containing a sensor model and a text file containing a list of ground control point, and performs a least-square fit of the sensor model adjustable parameters to these tie points. It produces an updated geom file as output, as well as an optional ground control points based statistics file and a vector file containing residues. The output geom file can then be used to ortho-rectify the data more accurately. Plaease note that for a proper use of the application, elevation must be correctly set (including DEM and geoid file). The map parameters allows to choose a map projection in which the accuracy will be estimated in meters.");
+    SetDocLongDescription("This application reads a geom file containing a sensor model and a text file containing a list of ground control point, and performs a least-square fit of the sensor model adjustable parameters to these tie points. It produces an updated geom file as output, as well as an optional ground control points based statistics file and a vector file containing residues. The output geom file can then be used to ortho-rectify the data more accurately. Plaease note that for a proper use of the application, elevation must be correctly set (including DEM and geoid file). The map parameters allows one to choose a map projection in which the accuracy will be estimated in meters.");
 
     AddDocTag(Tags::Geometry);
 
--- otb.orig/Applications/Projections/otbRigidTransformResample.cxx
+++ otb/Applications/Projections/otbRigidTransformResample.cxx
@@ -101,7 +101,7 @@
 
     //Transform
     AddParameter(ParameterType_Group,"transform","Transform parameters");
-    SetParameterDescription("transform","This group of parameters allows to set the transformation to apply.");
+    SetParameterDescription("transform","This group of parameters allows one to set the transformation to apply.");
 
     AddParameter(ParameterType_Choice, "transform.type", "Type of transformation");
     SetParameterDescription("transform.type","Type of transformation. Available transformations are spatial scaling, translation and rotation with scaling factor");
@@ -149,20 +149,20 @@
 
     // Interpolators
     AddParameter(ParameterType_Choice,   "interpolator", "Interpolation");
-    SetParameterDescription("interpolator","This group of parameters allows to define how the input image will be interpolated during resampling.");
+    SetParameterDescription("interpolator","This group of parameters allows one to define how the input image will be interpolated during resampling.");
     AddChoice("interpolator.nn",     "Nearest Neighbor interpolation");
     SetParameterDescription("interpolator.nn","Nearest neighbor interpolation leads to poor image quality, but it is very fast.");
     AddChoice("interpolator.linear", "Linear interpolation");
     SetParameterDescription("interpolator.linear","Linear interpolation leads to average image quality but is quite fast");
     AddChoice("interpolator.bco",    "Bicubic interpolation");
     AddParameter(ParameterType_Radius, "interpolator.bco.radius", "Radius for bicubic interpolation");
-    SetParameterDescription("interpolator.bco.radius","This parameter allows to control the size of the bicubic interpolation filter. If the target pixel size is higher than the input pixel size, increasing this parameter will reduce aliasing artefacts.");
+    SetParameterDescription("interpolator.bco.radius","This parameter allows one to control the size of the bicubic interpolation filter. If the target pixel size is higher than the input pixel size, increasing this parameter will reduce aliasing artefacts.");
     SetDefaultParameterInt("interpolator.bco.radius", 2);
     SetParameterString("interpolator","bco");
 
     // RAM available
     AddRAMParameter("ram");
-    SetParameterDescription("ram","This allows to set the maximum amount of RAM available for processing. As the writing task is time consuming, it is better to write large pieces of data, which can be achieved by increasing this parameter (pay attention to your system capabilities)");
+    SetParameterDescription("ram","This allows one to set the maximum amount of RAM available for processing. As the writing task is time consuming, it is better to write large pieces of data, which can be achieved by increasing this parameter (pay attention to your system capabilities)");
 
     // Doc example parameter settings
     SetDocExampleParameterValue("in", "qb_toulouse_sub.tif");
--- otb.orig/Applications/Projections/otbSuperimpose.cxx
+++ otb/Applications/Projections/otbSuperimpose.cxx
@@ -102,13 +102,13 @@
 
     // Interpolators
     AddParameter(ParameterType_Choice,   "interpolator", "Interpolation");
-    SetParameterDescription("interpolator","This group of parameters allows to define how the input image will be interpolated during resampling.");
+    SetParameterDescription("interpolator","This group of parameters allows one to define how the input image will be interpolated during resampling.");
 
     AddChoice("interpolator.bco",    "Bicubic interpolation");
     SetParameterDescription("interpolator.bco", "Bicubic interpolation leads to very good image quality but is slow.");
 
     AddParameter(ParameterType_Radius, "interpolator.bco.radius", "Radius for bicubic interpolation");
-    SetParameterDescription("interpolator.bco.radius","This parameter allows to control the size of the bicubic interpolation filter. If the target pixel size is higher than the input pixel size, increasing this parameter will reduce aliasing artefacts.");
+    SetParameterDescription("interpolator.bco.radius","This parameter allows one to control the size of the bicubic interpolation filter. If the target pixel size is higher than the input pixel size, increasing this parameter will reduce aliasing artefacts.");
     SetDefaultParameterInt("interpolator.bco.radius", 2);
 
     AddChoice("interpolator.nn",     "Nearest Neighbor interpolation");
--- otb.orig/Applications/Projections/otbVectorDataReprojection.cxx
+++ otb/Applications/Projections/otbVectorDataReprojection.cxx
@@ -62,13 +62,13 @@
   {
     SetName("VectorDataReprojection");
     std::ostringstream oss;
-    oss << "This application allows to reproject a vector data using support image projection reference"
+    oss << "This application allows one to reproject a vector data using support image projection reference"
         ", or a user specified map projection" << std::endl;
     SetDescription(oss.str());
     // Documentation
     SetDocName("Vector Data reprojection");
     oss.str("");
-    oss <<" This application allows to reproject a vector data using support image projection reference"
+    oss <<" This application allows one to reproject a vector data using support image projection reference"
         ", or a user given map projection." << std::endl;
     oss <<" If given, image keywordlist can be added to reprojected vectordata.";
     SetDocLongDescription(oss.str());
--- otb.orig/Applications/Radiometry/otbOpticalCalibration.cxx
+++ otb/Applications/Radiometry/otbOpticalCalibration.cxx
@@ -101,7 +101,7 @@
     SetDescription("Perform optical calibration TOA/TOC (Top Of Atmosphere/Top Of Canopy). Supported sensors: QuickBird, Ikonos, WorldView2, Formosat, Spot5, Pleiades");
     // Documentation
     SetDocName("Optical calibration");
-    SetDocLongDescription("The application allows to convert pixel values from DN (for Digital Numbers) to physically interpretable and comparable values. Calibrated values are called surface reflectivity and its values lie in the range [0, 1].\nThe first level is called Top Of Atmosphere (TOA) reflectivity. It takes into account the sensor gain, sensor spectral response and the solar illumination.\nThe second level is called Top Of Canopy (TOC) reflectivity. In addition to sensor gain and solar illumination, it takes into account the optical thickness of the atmosphere, the atmospheric pressure, the water vapor amount, the ozone amount, as well as the composition and amount of aerosol gasses.\nIt is also possible to indicate an AERONET file which contains atmospheric parameters (version 1 and version 2 of Aeronet file are supported.");
+    SetDocLongDescription("The application allows one to convert pixel values from DN (for Digital Numbers) to physically interpretable and comparable values. Calibrated values are called surface reflectivity and its values lie in the range [0, 1].\nThe first level is called Top Of Atmosphere (TOA) reflectivity. It takes into account the sensor gain, sensor spectral response and the solar illumination.\nThe second level is called Top Of Canopy (TOC) reflectivity. In addition to sensor gain and solar illumination, it takes into account the optical thickness of the atmosphere, the atmospheric pressure, the water vapor amount, the ozone amount, as well as the composition and amount of aerosol gasses.\nIt is also possible to indicate an AERONET file which contains atmospheric parameters (version 1 and version 2 of Aeronet file are supported.");
     SetDocLimitations("None");
     SetDocAuthors("OTB-Team");
     SetDocSeeAlso("The OTB CookBook");
@@ -123,7 +123,7 @@
 
     AddParameter(ParameterType_Empty, "milli", "Convert to milli reflectance");
     SetParameterDescription("milli", "Flag to use milli-reflectance instead of reflectance.\n"
-                            "This allows to save the image with integer pixel type (in the range [0, 1000]  instead of floating point in the range [0, 1]. In order to do that, use this option and set the output pixel type (-out filename uint16 for example)");
+                            "This allows one to save the image with integer pixel type (in the range [0, 1000]  instead of floating point in the range [0, 1]. In order to do that, use this option and set the output pixel type (-out filename uint16 for example)");
     DisableParameter("milli");
     MandatoryOff("milli");
 
@@ -140,7 +140,7 @@
     MandatoryOff("rsr");
 
     AddParameter(ParameterType_Group,"atmo","Atmospheric parameters");
-    SetParameterDescription("atmo","This group allows to set the atmospheric parameters.");
+    SetParameterDescription("atmo","This group allows one to set the atmospheric parameters.");
     AddParameter(ParameterType_Choice,   "atmo.aerosol", "Aerosol Model");
     AddChoice("atmo.aerosol.noaersol",    "No Aerosol Model");
     AddChoice("atmo.aerosol.continental", "Continental");
--- otb.orig/Applications/Segmentation/otbConnectedComponentSegmentation.cxx
+++ otb/Applications/Segmentation/otbConnectedComponentSegmentation.cxx
@@ -72,7 +72,7 @@
     SetName("ConnectedComponentSegmentation");
     SetDescription("Connected component segmentation and object based image filtering of the input image according to user-defined criterions.");
     SetDocName("Connected Component Segmentation");
-    SetDocLongDescription("This application allows to perform a masking, connected components segmentation and object based image filtering. First and optionally, a mask can be built based on user-defined criterions to select pixels of the image which will be segmented. Then a connected component segmentation is performed with a user defined criterion to decide whether two neighbouring pixels belong to the same segment or not. After this segmentation step, an object based image filtering is applied using another user-defined criterion reasoning on segment properties, like shape or radiometric attributes. " "Criterions are mathematical expressions analysed by the MuParser library (http://muparser.sourceforge.net/). For instance, expression \"((b1>80) and intensity>95)\" will merge two neighbouring pixel in a single segment if their intensity is more than 95 and their value in the first image band is more than 80. See parameters documentation for a list of available attributes. The output of the object based image filtering is vectorized and can be written in shapefile or KML format. If the input image is in raw geometry, resulting polygons will be transformed to WGS84 using sensor modelling before writing, to ensure consistency with GIS softwares. For this purpose, a Digital Elevation Model can be provided to the application. The whole processing is done on a per-tile basis for large images, so this application can handle images of arbitrary size.");
+    SetDocLongDescription("This application allows one to perform a masking, connected components segmentation and object based image filtering. First and optionally, a mask can be built based on user-defined criterions to select pixels of the image which will be segmented. Then a connected component segmentation is performed with a user defined criterion to decide whether two neighbouring pixels belong to the same segment or not. After this segmentation step, an object based image filtering is applied using another user-defined criterion reasoning on segment properties, like shape or radiometric attributes. " "Criterions are mathematical expressions analysed by the MuParser library (http://muparser.sourceforge.net/). For instance, expression \"((b1>80) and intensity>95)\" will merge two neighbouring pixel in a single segment if their intensity is more than 95 and their value in the first image band is more than 80. See parameters documentation for a list of available attributes. The output of the object based image filtering is vectorized and can be written in shapefile or KML format. If the input image is in raw geometry, resulting polygons will be transformed to WGS84 using sensor modelling before writing, to ensure consistency with GIS softwares. For this purpose, a Digital Elevation Model can be provided to the application. The whole processing is done on a per-tile basis for large images, so this application can handle images of arbitrary size.");
     SetDocLimitations("Due to the tiling scheme in case of large images, some segments can be arbitrarily split across multiple tiles.");
     SetDocAuthors("OTB-Team");
     SetDocSeeAlso(" ");
--- otb.orig/Applications/Segmentation/otbLSMSSegmentation.cxx
+++ otb/Applications/Segmentation/otbLSMSSegmentation.cxx
@@ -210,7 +210,7 @@
     SetDescription("Second step of the exact Large-Scale Mean-Shift segmentation workflow.");
 
     SetDocName("Exact Large-Scale Mean-Shift segmentation, step 2");
-    SetDocLongDescription("This application performs the second step of the exact Large-Scale Mean-Shift segmentation workflow (LSMS). Filtered range image and spatial image should be created with the MeanShiftSmoothing application, with modesearch parameter disabled. If spatial image is not set, the application will only process the range image and spatial radius parameter will not be taken into account. This application will produce a labeled image where neighbor pixels whose range distance is below range radius (and optionally spatial distance below spatial radius) will be grouped together into the same cluster. For large images one can use the nbtilesx and nbtilesy parameters for tile-wise processing, with the guarantees of identical results. Please note that this application will generate a lot of temporary files (as many as the number of tiles), and will therefore require twice the size of the final result in term of disk space. The cleanup option (activated by default) allows to remove all temporary file as soon as they are not needed anymore (if cleanup is activated, tmpdir set and tmpdir does not exists before running the application, it will be removed as well during cleanup). The tmpdir option allows to define a directory where to write the temporary files. Please also note that the output image type should be set to uint32 to ensure that there are enough labels available.");
+    SetDocLongDescription("This application performs the second step of the exact Large-Scale Mean-Shift segmentation workflow (LSMS). Filtered range image and spatial image should be created with the MeanShiftSmoothing application, with modesearch parameter disabled. If spatial image is not set, the application will only process the range image and spatial radius parameter will not be taken into account. This application will produce a labeled image where neighbor pixels whose range distance is below range radius (and optionally spatial distance below spatial radius) will be grouped together into the same cluster. For large images one can use the nbtilesx and nbtilesy parameters for tile-wise processing, with the guarantees of identical results. Please note that this application will generate a lot of temporary files (as many as the number of tiles), and will therefore require twice the size of the final result in term of disk space. The cleanup option (activated by default) allows one to remove all temporary file as soon as they are not needed anymore (if cleanup is activated, tmpdir set and tmpdir does not exists before running the application, it will be removed as well during cleanup). The tmpdir option allows one to define a directory where to write the temporary files. Please also note that the output image type should be set to uint32 to ensure that there are enough labels available.");
     SetDocLimitations("This application is part of the Large-Scale Mean-Shift segmentation workflow (LSMS) and may not be suited for any other purpose.");
     SetDocAuthors("David Youssefi");
     SetDocSeeAlso("MeanShiftSmoothing, LSMSSmallRegionsMerging, LSMSVectorization");
--- otb.orig/Applications/Segmentation/otbSegmentation.cxx
+++ otb/Applications/Segmentation/otbSegmentation.cxx
@@ -150,7 +150,7 @@
 
     // Documentation
     SetDocName("Segmentation");
-    SetDocLongDescription("This application allows to perform various segmentation algorithms on a multispectral image."
+    SetDocLongDescription("This application allows one to perform various segmentation algorithms on a multispectral image."
                           "Available segmentation algorithms are two different versions of Mean-Shift segmentation algorithm (one being multi-threaded),"
                           " simple pixel based connected components according to a user-defined criterion, and watershed from the gradient of the intensity"
                           " (norm of spectral bands vector). The application has two different modes that affects the nature of its output.\n\nIn raster mode,"
@@ -159,8 +159,8 @@
                           " can not handle large images. \n\nTo segment large data, one can use the vector mode. In this case, the output of the application is a"
                           " vector file or database. The input image is split into tiles (whose size can be set using the tilesize parameter), and each tile is loaded, segmented"
                           " with the chosen algorithm, vectorized, and written into the output file or database. This piece-wise behavior ensure that memory will never get overloaded,"
-                          " and that images of any size can be processed. There are few more options in the vector mode. The simplify option allows to simplify the geometry"
-                          " (i.e. remove nodes in polygons) according to a user-defined tolerance. The stitch option allows to application to try to stitch together polygons corresponding"
+                          " and that images of any size can be processed. There are few more options in the vector mode. The simplify option allows one to simplify the geometry"
+                          " (i.e. remove nodes in polygons) according to a user-defined tolerance. The stitch option allows one to application to try to stitch together polygons corresponding"
                           " to segmented region that may have been split by the tiling scheme. ");
 
     SetDocLimitations("In raster mode, the application can not handle large input images. Stitching step of vector mode might become slow with very large input images."
@@ -254,7 +254,7 @@
     SetParameterDescription("mode", "Choice of processing mode, either raster or large-scale.");
 
     AddChoice("mode.vector", "Tile-based large-scale segmentation with vector output");
-    SetParameterDescription("mode.vector","In this mode, the application will output a vector file or database, and process the input image piecewise. This allows to perform segmentation of very large images.");
+    SetParameterDescription("mode.vector","In this mode, the application will output a vector file or database, and process the input image piecewise. This allows one to perform segmentation of very large images.");
 
     AddChoice("mode.raster", "Standard segmentation with labeled raster output");
     SetParameterDescription("mode.raster","In this mode, the application will output a standard labeled raster. This mode can not handle large data.");
@@ -288,7 +288,7 @@
     SetParameterDescription("mode.vector.out", "The output vector file or database (name can be anything understood by OGR)");
 
     AddParameter(ParameterType_Choice,"mode.vector.outmode","Writing mode for the output vector file");
-    SetParameterDescription("mode.vector.outmode","This allows to set the writing behaviour for the output vector file. Please note that the actual behaviour depends on the file format.");
+    SetParameterDescription("mode.vector.outmode","This allows one to set the writing behaviour for the output vector file. Please note that the actual behaviour depends on the file format.");
 
     AddChoice("mode.vector.outmode.ulco","Update output vector file, only allow to create new layers");
     SetParameterDescription("mode.vector.outmode.ulco","The output vector file is opened in update mode if existing. If the output layer already exists, the application stops, leaving it untouched.");
@@ -328,7 +328,7 @@
 
     AddParameter(ParameterType_Float, "mode.vector.simplify", "Simplify polygons");
     SetParameterDescription("mode.vector.simplify",
-                            "Simplify polygons according to a given tolerance (in pixel). This option allows to reduce the size of the output file or database.");
+                            "Simplify polygons according to a given tolerance (in pixel). This option allows one to reduce the size of the output file or database.");
     SetDefaultParameterFloat("mode.vector.simplify",0.1);
     MandatoryOff("mode.vector.simplify");
     DisableParameter("mode.vector.simplify");
--- otb.orig/Applications/Utils/otbDownloadSRTMTiles.cxx
+++ otb/Applications/Utils/otbDownloadSRTMTiles.cxx
@@ -95,7 +95,7 @@
 
     // Documentation
     SetDocName("Download or list SRTM tiles related to a set of images");
-    SetDocLongDescription("This application allows to select the appropriate SRTM tiles that covers a list of images. It builds a list of the required tiles. Two modes are available: the first one download those tiles from the USGS SRTM3 website (http://dds.cr.usgs.gov/srtm/version2_1/SRTM3/), the second one list those tiles in a local directory. In both cases, you need to indicate the directory in which directory  tiles will be download or the location of local SRTM files.");
+    SetDocLongDescription("This application allows one to select the appropriate SRTM tiles that covers a list of images. It builds a list of the required tiles. Two modes are available: the first one download those tiles from the USGS SRTM3 website (http://dds.cr.usgs.gov/srtm/version2_1/SRTM3/), the second one list those tiles in a local directory. In both cases, you need to indicate the directory in which directory  tiles will be download or the location of local SRTM files.");
     SetDocLimitations("None");
     SetDocAuthors("OTB-Team");
     SetDocSeeAlso(" ");
--- otb.orig/Applications/Utils/otbReadImageInfo.cxx
+++ otb/Applications/Utils/otbReadImageInfo.cxx
@@ -70,7 +70,7 @@
     MandatoryOff("keywordlist");
 
     AddParameter(ParameterType_OutputFilename, "outkwl", "Write the OSSIM keywordlist to a geom file");
-    SetParameterDescription("outkwl", "This option allows to extract the OSSIM keywordlist of the image into a geom file.");
+    SetParameterDescription("outkwl", "This option allows one to extract the OSSIM keywordlist of the image into a geom file.");
     MandatoryOff("outkwl");
 
     //Create output parameters to store image informations
@@ -179,7 +179,7 @@
     EnableParameter("country");
 
     AddParameter(ParameterType_Group, "rgb", "Default RGB Display");
-    SetParameterDescription("rgb","This group of parameters allows to access to the default rgb composition.");
+    SetParameterDescription("rgb","This group of parameters allows one to access to the default rgb composition.");
 
     AddParameter(ParameterType_Int, "rgb.r", "Red Band");
     SetParameterDescription("rgb.r","Red band Number");
@@ -207,7 +207,7 @@
     EnableParameter("keyword");
 
     AddParameter(ParameterType_Group, "gcp", "Ground Control Points informations");
-    SetParameterDescription("gcp","This group of parameters allows to access to the GCPs informations.");
+    SetParameterDescription("gcp","This group of parameters allows one to access to the GCPs informations.");
     SetParameterRole("gcp", Role_Output);
 
     AddParameter(ParameterType_Int, "gcp.count", "GCPs Number");
--- otb.orig/RELEASE_NOTES.txt
+++ otb/RELEASE_NOTES.txt
@@ -1673,7 +1673,7 @@
 OTB-v.2.4.0 - Changes since version 2.2.0 (2008/07/24)
 --------------------------------------------------------
 
-	- Added OTB_DISABLE_CXX_EXAMPLES_TESTING : allows to generate or
+	- Added OTB_DISABLE_CXX_EXAMPLES_TESTING : allows one to generate or
 	  not only examples testing
 	- Added OTB_USE_JPEG2000 : experimental support for jpeg2000
 	  files.
@@ -2010,7 +2010,7 @@
 
 	- Added a new tiling streaming mode.
 
-	- Added the otb::ImageGeometryHandler, which allows to handle
+	- Added the otb::ImageGeometryHandler, which allows one to handle
 	  seamlessly
 	  the image geometry information.
 
@@ -2094,7 +2094,7 @@
 
 *Applications:
 
-	- Added the otbImageViewerManager application which allows to
+	- Added the otbImageViewerManager application which allows one to
 	  open multiple images,
 	  configure viewers and link displays.
 
@@ -2102,7 +2102,7 @@
 	  extraction algorithm
 	  implemented in the FeatureExtraction module.
 
-	- Added the otbOrthoRectifAppli application which allows to
+	- Added the otbOrthoRectifAppli application which allows one to
 	  ortho rectify images in
 	  command line using the brand new Projections module of the Orfeo
 	  ToolBox. Old rigid
--- otb.orig/Applications/Projections/otbGenerateRPCSensorModel.cxx
+++ otb/Applications/Projections/otbGenerateRPCSensorModel.cxx
@@ -62,7 +62,7 @@
     SetDescription("Generate a RPC sensor model from a list of Ground Control Points.");
 
     SetDocName("Generate a RPC sensor model");
-    SetDocLongDescription("This application generates a RPC sensor model from a list of Ground Control Points. At least 20 points are required for estimation wihtout elevation support, and 40 points for estimation with elevation support. Elevation support will be automatically deactivated if an insufficient amount of points is provided. The application can optionnaly output a file containing accuracy statistics for each point, and a vector file containing segments represening points residues. The map projection parameter allows to define a map projection in which the accuracy is evaluated.");
+    SetDocLongDescription("This application generates a RPC sensor model from a list of Ground Control Points. At least 20 points are required for estimation wihtout elevation support, and 40 points for estimation with elevation support. Elevation support will be automatically deactivated if an insufficient amount of points is provided. The application can optionnaly output a file containing accuracy statistics for each point, and a vector file containing segments represening points residues. The map projection parameter allows one to define a map projection in which the accuracy is evaluated.");
 
     AddDocTag(Tags::Geometry);
 
